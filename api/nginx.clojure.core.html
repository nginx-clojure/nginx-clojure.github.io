<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>nginx.clojure.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">nginx-clojure</span> <span class="project-version">0.4.3</span></span></a></h1></div><div class="sidebar primary"><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>nginx</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-3 branch current"><a href="nginx.clojure.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-3 branch"><a href="nginx.clojure.embed.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>embed</span></div></a></li><li class="depth-3"><a href="nginx.clojure.session.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>session</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="nginx.clojure.core.html#var-achannel"><div class="inner"><span>achannel</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-AsynchronousChannel"><div class="inner"><span>AsynchronousChannel</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-aclose.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aclose!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-aclosed.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aclosed?</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-aconnect.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aconnect!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-aget-context"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aget-context</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-arecv.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>arecv!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-asend.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>asend!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-aset-context.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aset-context!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-aset-timeout.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>aset-timeout!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-ashutdown.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>ashutdown!</span></div></a></li><li class="depth-2"><a href="nginx.clojure.core.html#var-error-str"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>error-str</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-broadcast.21"><div class="inner"><span>broadcast!</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-build-topic.21"><div class="inner"><span>build-topic!</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-co-pcalls"><div class="inner"><span>co-pcalls</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-co-pvalues"><div class="inner"><span>co-pvalues</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-get-ngx-var"><div class="inner"><span>get-ngx-var</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-hijack.21"><div class="inner"><span>hijack!</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-HttpServerChannel"><div class="inner"><span>HttpServerChannel</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-add-aggregated-listener.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-aggregated-listener!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-add-listener.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>add-listener!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-close.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>close!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-closed.3F"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>closed?</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-get-context"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>get-context</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-on-close.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>on-close!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-send.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>send!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-send-header.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>send-header!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-send-response.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>send-response!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-set-context.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>set-context!</span></div></a></li><li class="depth-2"><a href="nginx.clojure.core.html#var-websocket-upgrade.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>websocket-upgrade!</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-on-broadcast.21"><div class="inner"><span>on-broadcast!</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-on-broadcast-event-decode.21"><div class="inner"><span>on-broadcast-event-decode!</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-phase-done"><div class="inner"><span>phase-done</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-phrase-done"><div class="inner"><span>phrase-done</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-process-id"><div class="inner"><span>process-id</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-PubSubTopic"><div class="inner"><span>PubSubTopic</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-destory.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>destory!</span></div></a></li><li class="depth-2 branch"><a href="nginx.clojure.core.html#var-pub.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>pub!</span></div></a></li><li class="depth-2"><a href="nginx.clojure.core.html#var-sub.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sub!</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-set-ngx-var.21"><div class="inner"><span>set-ngx-var!</span></div></a></li><li class="depth-1"><a href="nginx.clojure.core.html#var-without-coroutine"><div class="inner"><span>without-coroutine</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">nginx.clojure.core</h1><div class="doc"><pre class="plaintext">Core functions.
</pre></div><div class="public anchor" id="var-achannel"><h3>achannel</h3><div class="usage"><code>(achannel)</code></div><div class="doc"><pre class="plaintext">create an asynchronous socket channal.
</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L248">view source</a></div></div><div class="public anchor" id="var-AsynchronousChannel"><h3>AsynchronousChannel</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext">Only works on non-threadpool mode, viz. coroutine mode or default mode.
</pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-aclose.21"><h3>aclose!</h3><div class="usage"><code>(aclose! ch)</code></div><div class="doc"><pre class="plaintext">Close the channel
</pre></div></div><div class="public anchor" id="var-aclosed.3F"><h3>aclosed?</h3><div class="usage"><code>(aclosed? ch)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-aconnect.21"><h3>aconnect!</h3><div class="usage"><code>(aconnect! ch url attachment on-err on-done)</code></div><div class="doc"><pre class="plaintext">Connect to the remote url.
     `url can be &quot;192.168.2.34:80&quot; , &quot;www.bing.com:80&quot;, or unix domain socket &quot;unix:/var/mytest/server.sock&quot;
     `on-err and `on-done are  functions which have the form (fn[status,attachment]
      when passed to `on-err, `status is an error code which range from 
NginxClojureAsynSocket.NGX_HTTP_CLOJURE_SOCKET_ERR to NGX_HTTP_CLOJURE_SOCKET_ERR_OUTOFMEMORY
      when passed to `on-done `status is always 0. </pre></div></div><div class="public anchor" id="var-aget-context"><h3>aget-context</h3><div class="usage"><code>(aget-context ch)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-arecv.21"><h3>arecv!</h3><div class="usage"><code>(arecv! ch buf attachment on-err on-done)</code></div><div class="doc"><pre class="plaintext">receive data from the channel.
     `buf can be byte[] or ByteBuffer
     `on-err and `on-done are  functions which have the form (fn[status,attachment]
      when passed to `on-err, `status is an error code which is eof (0) or range from 
NginxClojureAsynSocket.NGX_HTTP_CLOJURE_SOCKET_ERR to NGX_HTTP_CLOJURE_SOCKET_ERR_OUTOFMEMORY
      when passed to `on-done `status is always &gt; 0 and means number of bytes received.
     </pre></div></div><div class="public anchor" id="var-asend.21"><h3>asend!</h3><div class="usage"><code>(asend! ch data attachment on-err on-done)</code></div><div class="doc"><pre class="plaintext">send data to the channel.
     `data can be String, byte[] or ByteBuffer
     `on-err and `on-done are  functions which have the form (fn[status,attachment]
      when passed to `on-err, `status is an error code which is eof (0) or range from 
NginxClojureAsynSocket.NGX_HTTP_CLOJURE_SOCKET_ERR to NGX_HTTP_CLOJURE_SOCKET_ERR_OUTOFMEMORY
      when passed to `on-done `status is always &gt; 0 and means number of bytes sent.</pre></div></div><div class="public anchor" id="var-aset-context.21"><h3>aset-context!</h3><div class="usage"><code>(aset-context! ch ctx)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-aset-timeout.21"><h3>aset-timeout!</h3><div class="usage"><code>(aset-timeout! ch connect-timeout read-timeout write-timeout)</code></div><div class="doc"><pre class="plaintext">The timeout unit is millisecond.
if timeout &lt; 0 it will be ignored, if timeout = 0 it means no timeout settings</pre></div></div><div class="public anchor" id="var-ashutdown.21"><h3>ashutdown!</h3><div class="usage"><code>(ashutdown! ch how)</code></div><div class="doc"><pre class="plaintext">shutdown some kind of events trigger of the socket
`how can be :soft-read :soft-write :soft-both :read :write :both. If we use :soft-xxx it won&apos;t 
shutdown the physical socket and just turn off the events trigger for better performance.
Otherwise it will shutdown the physical socket, more details can be found from <a href="http://linux.die.net/man/2/shutdown">http://linux.die.net/man/2/shutdown</a></pre></div></div><div class="public anchor" id="var-error-str"><h3>error-str</h3><div class="usage"><code>(error-str ch code)</code></div><div class="doc"><pre class="plaintext">return the error string message from the error code
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L127">view source</a></div></div><div class="public anchor" id="var-broadcast.21"><h3>broadcast!</h3><div class="usage"><code>(broadcast! event)</code></div><div class="doc"><pre class="plaintext">Broadcast a  event to all nginx worker processes. 
   This function can be used to notify all subscribers in different nginx
worker processes from the same nginx instance.
   `event has the form {:data data} or {:tag tag, :data data} 
   `data can be Long, String, byte[]. If it is long integer it must be less than 0x0100000000000000L
If it is string or bytes, it must be less than PIPE_BUF - 8, generally on Linux/Windows is 4088, 
on MacosX is 504
	 `data will be truncated if its length exceeds this limitation.
   If `tag is given, `data can also be long integer which means this event is 
   very simple and only has a event id without any body or body is stored externally.
   The default tag value is 0x20 when `msg is Long otherwise the default value is 0x80.
   Here is a list of `tag values range:
   * System Event :0x00 ~ 0x1f -- Application should not use them
	 * Application Event : 0x20 ~ 0xff
	 * Simple  Event : 0x00 ~ 0x7f, only event id (7Byte), no message body
	 * Complex Event : 0x80 ~ 0xff</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L253">view source</a></div></div><div class="public anchor" id="var-build-topic.21"><h3>build-topic!</h3><div class="usage"><code>(build-topic! name)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L307">view source</a></div></div><div class="public anchor" id="var-co-pcalls"><h3>co-pcalls</h3><div class="usage"><code>(co-pcalls &amp; fns)</code></div><div class="doc"><pre class="plaintext">Executes the no-arg fns in parallel coroutines, returning a  sequence of their values
If there&apos;s no coroutine support, it will turn to use thread pool to make testing with lein-ring easy.
e.g. fetch two services in parallel:
(let [[r1, r2] (co-pcalls (fn[] (client/get &quot;<a href="http://page1-url&quot;))">http://page1-url&quot;))</a> (fn[] (client/get &quot;<a href="http://page2-url&quot;)))">http://page2-url&quot;)))</a>]
 ;println bodies of two remote responses
 (println (str (:body r1) &quot;====\n&quot; (:body r2) ))
</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L36">view source</a></div></div><div class="public anchor" id="var-co-pvalues"><h3>co-pvalues</h3><h4 class="type">macro</h4><div class="usage"><code>(co-pvalues &amp; exprs)</code></div><div class="doc"><pre class="plaintext">Returns a sequence of the values of the exprs, which are evaluated in parallel coroutines.
If there&apos;s no coroutine support, it will turn to use thread pool to make testing with lein-ring easy.
e.g. fetch two services in parallel:
(let [[r1, r2] (co-pvalues (client/get &quot;<a href="http://page1-url&quot;)">http://page1-url&quot;)</a> (client/get &quot;<a href="http://page2-url&quot;))">http://page2-url&quot;))</a>]
 ;println bodies of two remote responses
 (println (str (:body r1) &quot;====\n&quot; (:body r2) ))
</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L25">view source</a></div></div><div class="public anchor" id="var-get-ngx-var"><h3>get-ngx-var</h3><div class="usage"><code>(get-ngx-var req name)</code></div><div class="doc"><pre class="plaintext">get nginx variable
</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L52">view source</a></div></div><div class="public anchor" id="var-hijack.21"><h3>hijack!</h3><div class="usage"><code>(hijack! req ignore-nginx-filter?)</code></div><div class="doc"><pre class="plaintext">Hijack a nginx request and return a server channel.
After being hijacked, the ring handler&apos;s result will be ignored.
If ignore-nginx-filter? is true all data output to channel won&apos;t be filtered
by any nginx HTTP header/body filters such as gzip filter, chucked filter, etc.
We can use this function to implement long polling / Server Sent Events (SSE) easily.</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L66">view source</a></div></div><div class="public anchor" id="var-HttpServerChannel"><h3>HttpServerChannel</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-add-aggregated-listener.21"><h3>add-aggregated-listener!</h3><div class="usage"><code>(add-aggregated-listener! ch max-message-size callbacks-map)</code></div><div class="doc"><pre class="plaintext">Add an aggregated message listener.
callbacks-map is a map whose key can be either of :on-open,:on-message,:on-close,:on-error
the value of :on-open is a function like (fn[ch]...)
the value of :on-message is a function like (fn[ch message]...)
the value of :on-close is a function like (fn[ch reason]...)
the value of :on-error is a function like (fn[ch status])
</pre></div></div><div class="public anchor" id="var-add-listener.21"><h3>add-listener!</h3><div class="usage"><code>(add-listener! ch callbacks-map)</code></div><div class="doc"><pre class="plaintext">Add a channel event listener.
callbacks-map is a map whose key can be either of :on-open,:on-message,:on-close,:on-error
the value of :on-open is a function like (fn[ch]...)
the value of :on-message is a function like (fn[ch message remaining?]...)
the value of :on-close is a function like (fn[ch reason]...)
the value of :on-error is a function like (fn[ch status])
</pre></div></div><div class="public anchor" id="var-close.21"><h3>close!</h3><div class="usage"><code>(close! ch)</code></div><div class="doc"><pre class="plaintext">Asynchronously close the channel. If there&apos;s remaining data to send it won&apos;t block 
current thread  and will flush data on the background asynchronously and later close the channel safely</pre></div></div><div class="public anchor" id="var-closed.3F"><h3>closed?</h3><div class="usage"><code>(closed? ch)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-get-context"><h3>get-context</h3><div class="usage"><code>(get-context ch)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-on-close.21"><h3>on-close!</h3><div class="usage"><code>(on-close! ch attachment listener)</code></div><div class="doc"><pre class="plaintext">Add a close event listener.
`attachement is a  object which will be passed to listener when close event happens
`listener is a function like (fn[attachement] ... )
A close event will happen immediately when a channel is closed by either of these three cases:
(1) channel close function/method is invoked on this channel, e.g. (close! ch)
(2) inner unrecoverable error happens with this channel, e.g. not enough memory to read/write
(3) remote client connection is closed or broken.</pre></div></div><div class="public anchor" id="var-send.21"><h3>send!</h3><div class="usage"><code>(send! ch data flush? last?)</code></div><div class="doc"><pre class="plaintext">Asynchronously send data to channel without blocking current thread. 
data can be byte[], String, or ByteBuffer
If flush? is false it will put data into buffers chain eitherwise it will write data to network.
If close? is true it will close channel after all data are sent.
</pre></div></div><div class="public anchor" id="var-send-header.21"><h3>send-header!</h3><div class="usage"><code>(send-header! ch status headers flush? last?)</code></div><div class="doc"><pre class="plaintext">Asynchronously send HTTP status &amp; headers to channel.
status is a integer for HTTP status code, headers is a HTTP headers map.
If flush? is false it will put data into buffers chain eitherwise it will write data to network.
If close? is true it will close channel after all data are sent.</pre></div></div><div class="public anchor" id="var-send-response.21"><h3>send-response!</h3><div class="usage"><code>(send-response! ch resp)</code></div><div class="doc"><pre class="plaintext">Asynchronously send a complete HTTP response to channel and close channel after all data are sent.
resp is a ring Response Map, e.g. {:status 200, headers {&quot;Content-Type&quot; &quot;text/html&quot;}, :body &quot;Hello, Nginx-Clojure!&quot; } .
</pre></div></div><div class="public anchor" id="var-set-context.21"><h3>set-context!</h3><div class="usage"><code>(set-context! ch ctx)</code></div><div class="doc"><pre class="plaintext"></pre></div></div><div class="public anchor" id="var-websocket-upgrade.21"><h3>websocket-upgrade!</h3><div class="usage"><code>(websocket-upgrade! ch send-err-for-nonwebsocekt?)</code></div><div class="doc"><pre class="plaintext">Send upgrade headers and return true if upgrade success
If `send-err-for-nonwebsocekt?` is true it will send error response.
</pre></div></div></div></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L75">view source</a></div></div><div class="public anchor" id="var-on-broadcast.21"><h3>on-broadcast!</h3><div class="usage"><code>(on-broadcast! f)</code></div><div class="doc"><pre class="plaintext">Add a broadcasted event listener and return a removal function to delete the listener
Function f is like (fn[event] ... ) and event has the form {:tag tag, :data `bytes or long`, :offset offset :length length }
`offset &amp; `length are meamingless if data is a long integer.</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L281">view source</a></div></div><div class="public anchor" id="var-on-broadcast-event-decode.21"><h3>on-broadcast-event-decode!</h3><div class="usage"><code>(on-broadcast-event-decode! tester decoder)</code></div><div class="doc"><pre class="plaintext">Add a pair of tester &amp; decoder to broadcast event decoder chain
and return a removal function to delete the decoder.
   Decoders will be called one by one and the current decode result will be past to the next decoder.
   Decoders should return decoded event which has the form {:tag tag, :data `any type of data`, :offset offset :length length }
   offset &amp; `length are meamingless if data is a long integer.
   Function tester is a checker and only if it return true the decoder will be invoked.</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L292">view source</a></div></div><div class="public anchor" id="var-phase-done"><h3>phase-done</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L64">view source</a></div></div><div class="public anchor" id="var-phrase-done"><h3>phrase-done</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L62">view source</a></div></div><div class="public anchor" id="var-process-id"><h3>process-id</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L13">view source</a></div></div><div class="public anchor" id="var-PubSubTopic"><h3>PubSubTopic</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-destory.21"><h3>destory!</h3><div class="usage"><code>(destory! topic)</code></div><div class="doc"><pre class="plaintext">Destory the topic.
</pre></div></div><div class="public anchor" id="var-pub.21"><h3>pub!</h3><div class="usage"><code>(pub! topic message)</code></div><div class="doc"><pre class="plaintext">Publishs a message to the topic
</pre></div></div><div class="public anchor" id="var-sub.21"><h3>sub!</h3><div class="usage"><code>(sub! topic att callback)</code></div><div class="doc"><pre class="plaintext">Subscribes to a topic and returns an unsubscribing function. 
When a message comes the callback function will be invoked. e.g.
      (def my-topic (build-topic! &quot;my-topic&quot;))
      (sub! my-topic (atomic 0) 
           (function [message counter]
              (println &quot;received :&quot; message &quot;, times=&quot; (swap counter inc)))</pre></div></div></div></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L311">view source</a></div></div><div class="public anchor" id="var-set-ngx-var.21"><h3>set-ngx-var!</h3><div class="usage"><code>(set-ngx-var! req name val)</code></div><div class="doc"><pre class="plaintext">set nginx variable
</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L57">view source</a></div></div><div class="public anchor" id="var-without-coroutine"><h3>without-coroutine</h3><div class="usage"><code>(without-coroutine f)</code></div><div class="doc"><pre class="plaintext">wrap a handler `f` to a new handler which will keep away the coroutine context
</pre></div><div class="src-link"><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/src/clojure/nginx/clojure/core.clj#L15">view source</a></div></div></div></body></html>