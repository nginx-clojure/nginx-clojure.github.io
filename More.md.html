<h1>
<a id="user-content-3-more-about-nginx-clojure" class="anchor" href="#3-more-about-nginx-clojure" aria-hidden="true"><span class="octicon octicon-link"></span></a>3. More about Nginx-Clojure</h1>

<h2>
<a id="user-content-30-more-about-apis" class="anchor" href="#30-more-about-apis" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.0 More about APIs</h2>

<h3>
<a id="user-content-request--response" class="anchor" href="#request--response" aria-hidden="true"><span class="octicon octicon-link"></span></a>Request &amp; Response</h3>

<p>For Clojure the request map and response map are defined by the ring SEPC at <a href="https://github.com/ring-clojure/ring/blob/master/SPEC">https://github.com/ring-clojure/ring/blob/master/SPEC</a> .</p>

<p>For Java/Groovy , the reqest map contains serveral parts:</p>

<ol>
<li>server-port (Required, Integer) The port on which the request is being handled.</li>
<li>server-name (Required, String) The resolved server name, or the server IP address.</li>
<li>remote-addr (Required, String) The IP address of the client or the last proxy that sent the request.</li>
<li>uri (Required, String) The request URI, excluding the query string and the "?" separator. Must start with "/".</li>
<li>query-string (Optional, String) The query string, if present.</li>
<li>scheme (Required, String) The transport protocol, must be one of http or https.</li>
<li>request-method (Required, String) The HTTP request method, must be a lowercase keyword corresponding to a HTTP request method, such as :get or :post.</li>
<li>content-type <strong>DEPRECATED</strong> (Optional, String)The MIME type of the request body, if known.</li>
<li>content-length <strong>DEPRECATED</strong> (Optional, Integer) The number of bytes in the request body, if known.</li>
<li>character-encoding <strong>DEPRECATED</strong> (Optional, String) The name of the character encoding used in the request body, if known.</li>
<li>sl-client-cert (Optional, X509Certificate) The SSL client certificate, if supplied. This value  is not <strong>supported</strong> yet.</li>
<li>headers (Required, Map) A map of header name Strings to corresponding header value Strings.</li>
<li>body (Optional, InputStream) An InputStream for the request body, if present.</li>
</ol>

<p>The return response is an array of object, e.g</p>

<div class="highlight highlight-source-java"><pre>
 [<span class="pl-c1">200</span>, <span class="pl-c">//http status 200 </span>
   <span class="pl-smi">ArrayMap</span><span class="pl-k">.</span>create(<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text/html<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> ), <span class="pl-c">//headers map</span>
   <span class="pl-s"><span class="pl-pds">"</span>Hello, Java &amp; Nginx!<span class="pl-pds">"</span></span> <span class="pl-c">//response body can be string, File or Array/Collection of string or File ]; </span></pre></div>

<blockquote>
<p>Note that If the rewrite/access handler returns phase-done (Clojure) or Constants.PHRASE_DONE (Groovy/Java), nginx will continue to next phases (e.g. invoke proxy_pass or content ring handler). If the rewrite handler returns a general response, nginx will send this response to the client and stop to continue to next phases.</p>
</blockquote>

<h2>
<a id="user-content-31-handle-multiple-coroutine-based-sockets-parallel" class="anchor" href="#31-handle-multiple-coroutine-based-sockets-parallel" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.1 Handle Multiple Coroutine Based Sockets Parallel</h2>

<p>Sometimes we need invoke serveral remote services before completing the ring  response. For better performance we need a way to handle multiple sockets parallel in sub coroutines.</p>

<p>e.g. fetch two page parallel by clj-http</p>

<div class="highlight highlight-source-clojure"><pre>   (<span class="pl-k">let</span> [[r1, r2] 
                (<span class="pl-en">co-pvalues</span> (<span class="pl-en">client/get</span> <span class="pl-s"><span class="pl-pds">"</span>http://service1-url<span class="pl-pds">"</span></span>) 
                            (<span class="pl-en">client/get</span> <span class="pl-s"><span class="pl-pds">"</span>http://service2-url<span class="pl-pds">"</span></span>))]
    <span class="pl-c">;println bodies of two remote response</span>
    (<span class="pl-en">println</span> (<span class="pl-en">str</span> (<span class="pl-c1">:body</span> r1) <span class="pl-s"><span class="pl-pds">"</span>====<span class="pl-cce">\n</span><span class="pl-pds">"</span></span> (<span class="pl-c1">:body</span> r2) ))</pre></div>

<p>Here <code>co-pvalues</code> is also non-blocking and coroutine based. In fact it will create two sub coroutines to handle two sockets.</p>

<p>For Java/Groovy, we can use <code>NginxClojureRT.coBatchCall</code> to do the same thing. Here 's a simple example for Groovy.</p>

<div class="highlight highlight-source-groovy"><pre>     <span class="pl-k">def</span> (r1, r2) <span class="pl-k">=</span> <span class="pl-k">NginxClojureRT</span><span class="pl-k">.</span>coBatchCall( 
       {<span class="pl-s"><span class="pl-pds">"</span>http://mirror.bit.edu.cn/apache/httpcomponents/httpclient/<span class="pl-pds">"</span></span><span class="pl-k">.</span>toURL()<span class="pl-k">.</span>text},
       {<span class="pl-s"><span class="pl-pds">"</span>http://mirror.bit.edu.cn/apache/httpcomponents/httpcore/<span class="pl-pds">"</span></span><span class="pl-k">.</span>toURL()<span class="pl-k">.</span>text})
     <span class="pl-k">return</span> [<span class="pl-c1">200</span>, [<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>text/html<span class="pl-pds">"</span></span>], r1 <span class="pl-k">+</span> r2];
</pre></div>

<h2>
<a id="user-content-32-shared-map-among-nginx-workers" class="anchor" href="#32-shared-map-among-nginx-workers" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.2 Shared Map among Nginx Workers</h2>

<p>See <a href="sharedmap.html">Shared Map &amp; Session Store</a>.</p>

<h2>
<a id="user-content-33-user-defined-http-method" class="anchor" href="#33-user-defined-http-method" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.3 User Defined Http Method</h2>

<p>Some web services need user defined http request method to define special operations beyond standard http request methods. </p>

<p>e.g. We use <code>MYUPLOAD</code> to upload a file and overwrite the one if it exists.  The <code>curl</code> command maybe is </p>

<div class="highlight highlight-source-shell"><pre>curl   -v  -X MYUPLOAD  --upload-file post-test-data \
<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8080/myservice<span class="pl-pds">"</span></span> </pre></div>

<p>In the nginx.conf, we can use <code>always_read_body on;</code> to force nginx to read http body.</p>

<div class="highlight highlight-source-nginx"><pre>
<span class="pl-k">location</span> <span class="pl-en">/myservice </span>{
         <span class="pl-k">handler_type</span> <span class="pl-s">'clojure'</span>;
         <span class="pl-k">always_read_body</span> on;
         <span class="pl-k">content_handler_code</span> <span class="pl-s">'....'</span>;
}
</pre></div>

<h2>
<a id="user-content-34-server-channel-for-long-polling--server-sent-events-sse" class="anchor" href="#34-server-channel-for-long-polling--server-sent-events-sse" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.4 Server Channel for Long Polling &amp; Server Sent Events (SSE)</h2>

<p>Since v0.2.5, nginx-clojure provides union form of <a href="https://github.com/nginx-clojure/nginx-clojure/issues/41">hijack API</a> to do with Long Polling &amp; Server Sent Events (SSE).</p>

<h3>
<a id="user-content-hijack-the-request" class="anchor" href="#hijack-the-request" aria-hidden="true"><span class="octicon octicon-link"></span></a>Hijack the Request</h3>

<p>We can hijack the request to get a http server channel to sent some messages later. After hijacking the return result from ring handler will be ignore so we can finely control when &amp; what to be sent to the client.</p>

<p>For Clojure</p>

<div class="highlight highlight-source-clojure"><pre>
(<span class="pl-k">fn</span> my-handler[req]
         (<span class="pl-k">let</span> [ch (<span class="pl-en">hijack!</span> req <span class="pl-c1">true</span>)]
          <span class="pl-c">;;; save channel ch to use it later     </span>
))</pre></div>

<p>The complete <code>hijack!</code> description is below </p>

<div class="highlight highlight-source-clojure"><pre>
(<span class="pl-k">defn</span> <span class="pl-e">hijack!</span> 
  <span class="pl-s"><span class="pl-pds">"</span>Hijack a nginx request and return a server channel.</span>
<span class="pl-s">   After being hijacked, the ring handler's result will be ignored.</span>
<span class="pl-s">   If ignore-nginx-filter? is true all data output to channel won't be filtered</span>
<span class="pl-s">   by any nginx HTTP header/body filters such as gzip filter, chucked filter, etc.</span>
<span class="pl-s">   We can use this function to implement long polling / Server Sent Events (SSE) easily.<span class="pl-pds">"</span></span>
  [^NginxRequest req ignore-nginx-filter?])</pre></div>

<p>For Java</p>

<div class="highlight highlight-source-java"><pre>
    <span class="pl-k">public</span>  <span class="pl-k">class</span> <span class="pl-en">MyHandler</span> <span class="pl-k">implements</span> <span class="pl-e">NginxJavaRingHandler</span> {

        <span class="pl-k">@Override</span>
        <span class="pl-k">public</span> <span class="pl-k">Object</span>[] <span class="pl-en">invoke</span>(<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Object</span>&gt;</span> <span class="pl-v">request</span>) {
            <span class="pl-smi">NginxJavaRequest</span> r <span class="pl-k">=</span> ((<span class="pl-smi">NginxJavaRequest</span>)request);
            <span class="pl-smi">NginxHttpServerChannel</span> channel <span class="pl-k">=</span> r<span class="pl-k">.</span>handler()<span class="pl-k">.</span>hijack(r, <span class="pl-c1">true</span>);           
            <span class="pl-c">//save channel ch to use it later    </span>
            <span class="pl-c">//nginx-clojure will ignore this return because we have hijacked the request.</span>
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
    }</pre></div>

<p>The complete java doc about hijack is below</p>

<div class="highlight highlight-source-java"><pre>    <span class="pl-c">/**</span>
<span class="pl-c">     * Get a hijacked Server Channel used to send message later typically in another thread</span>
<span class="pl-c">     * If ignoreFilter is true all data output to channel won't be filtered</span>
<span class="pl-c">     * by any nginx HTTP header/body filters such as gzip filter, chucked filter, etc.</span>
<span class="pl-c">     * @param req the request object</span>
<span class="pl-c">     * @param ignoreFilter whether we need ignore nginx filter or not.</span>
<span class="pl-c">     * @return hijacked channel used to send message later</span>
<span class="pl-c">     */</span>
    <span class="pl-k">public</span> <span class="pl-smi">NginxHttpServerChannel</span> hijack(<span class="pl-smi">NginxRequest</span> req, <span class="pl-k">boolean</span> ignoreFilter);</pre></div>

<h3>
<a id="user-content-send-a-complete-response-for-long-polling" class="anchor" href="#send-a-complete-response-for-long-polling" aria-hidden="true"><span class="octicon octicon-link"></span></a>Send a Complete Response for Long Polling</h3>

<p>When some event happen which let a complete response must be sent to the Long Polling request client we can use <code>send-response!</code>(Clojure) or sendResponse (Java/Groovy) to send a complete response. This action is non-blocking and after completion the channel will be closed automatically.</p>

<p>For Clojure</p>

<div class="highlight highlight-source-clojure"><pre>
(<span class="pl-en">send-response!</span> ch {<span class="pl-c1">:status</span> <span class="pl-c1">200</span>, <span class="pl-c1">:headers</span> {<span class="pl-s"><span class="pl-pds">"</span>content-type<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>text/plain<span class="pl-pds">"</span></span>}, <span class="pl-c1">:body</span> data}</pre></div>

<p>For Java</p>

<div class="highlight highlight-source-java"><pre>
channel<span class="pl-k">.</span>sendResponse(<span class="pl-k">new</span> <span class="pl-smi">Object</span>[] { <span class="pl-c1">NGX_HTTP_OK</span>,
                <span class="pl-smi">ArrayMap</span><span class="pl-k">.</span>create(<span class="pl-s"><span class="pl-pds">"</span>content-type<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text/json<span class="pl-pds">"</span></span>),
                message});</pre></div>

<h3>
<a id="user-content-send-messages-for-server-sent-events-sse" class="anchor" href="#send-messages-for-server-sent-events-sse" aria-hidden="true"><span class="octicon octicon-link"></span></a>Send Messages for Server Sent Events (SSE)</h3>

<p>First we can use <code>send-headers!</code>(Clojure) or <code>sendHeaders</code> (Java/Groovy) to send a SSE header. Then we
can use <code>send!</code> (Clojure) or <code>send</code> (Java/Groovy) to send later messages. The last two parameters of send
function is used to flush message or close channel after sending current message.</p>

<p>For Clojure:</p>

<div class="highlight highlight-source-clojure"><pre>
 <span class="pl-c">;;; send header and retry hint of SSE</span>
 (<span class="pl-en">send-header!</span> ch <span class="pl-c1">200</span> {<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text/event-stream<span class="pl-pds">"</span></span>} <span class="pl-c1">false</span> <span class="pl-c1">false</span>)
 (<span class="pl-en">send!</span> ch <span class="pl-s"><span class="pl-pds">"</span>retry: 4500<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span> <span class="pl-c1">true</span> <span class="pl-c1">false</span>)

 <span class="pl-c">;;; send the message and do flush </span>
 (<span class="pl-en">send!</span> ch <span class="pl-s"><span class="pl-pds">"</span>data: Are you ok?<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span> <span class="pl-c1">true</span> <span class="pl-c1">false</span>)

 <span class="pl-c">;;; send the last message, identical to (send! ch data true false) (close! ch)</span>
 (<span class="pl-en">send!</span> ch <span class="pl-s"><span class="pl-pds">"</span>data: Bye, bye.<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span> <span class="pl-c1">true</span> <span class="pl-c1">true</span>)
</pre></div>

<p>For Java:</p>

<div class="highlight highlight-source-java"><pre>
<span class="pl-c">//send header and retry hint of SSE</span>
channel<span class="pl-k">.</span>sendHeader(<span class="pl-c1">200</span>, <span class="pl-smi">ArrayMap</span><span class="pl-k">.</span>create(<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text/event-stream<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>entrySet(), <span class="pl-c1">true</span>, <span class="pl-c1">false</span>);
channel<span class="pl-k">.</span>send(<span class="pl-s"><span class="pl-pds">"</span>retry: 4500<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>, <span class="pl-c1">false</span>);

<span class="pl-c">//send the message and do flush </span>
channel<span class="pl-k">.</span>send(<span class="pl-s"><span class="pl-pds">"</span>data: Are you ok?<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>, <span class="pl-c1">false</span>)

<span class="pl-c">//send the last message, identical to channel.send(data true false); channel.close();</span>
channel<span class="pl-k">.</span>send(<span class="pl-s"><span class="pl-pds">"</span>data: Bye, bye.<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>, <span class="pl-c1">true</span>)</pre></div>

<h3>
<a id="user-content-listener-about-the-closed-event-of-channel" class="anchor" href="#listener-about-the-closed-event-of-channel" aria-hidden="true"><span class="octicon octicon-link"></span></a>Listener about the Closed Event of Channel</h3>

<p>A closed event will happen immediately when channel is closed by either of these three cases:</p>

<ul>
<li>channel close function/method is invoked on this channel, e.g. (close! ch)</li>
<li>inner unrecoverable error happens with this channel, e.g. not enough memory to read/write</li>
<li>remote client connection is closed or broken.</li>
</ul>

<p>For Clojure</p>

<div class="highlight highlight-source-clojure"><pre>
(<span class="pl-en">on-close!</span> ch {<span class="pl-c1">:ch</span> ch <span class="pl-c1">:desc</span> <span class="pl-s"><span class="pl-pds">"</span>this is a event attachement<span class="pl-pds">"</span></span>}
 (<span class="pl-en">fn[att]</span> (<span class="pl-en">info</span> <span class="pl-s"><span class="pl-pds">"</span>closed channel from request :<span class="pl-pds">"</span></span> (<span class="pl-en">.request</span> (<span class="pl-c1">:ch</span> att)))))</pre></div>

<p>For Java</p>

<div class="highlight highlight-source-java"><pre>
channel<span class="pl-k">.</span>addListener(channel, <span class="pl-k">new</span> <span class="pl-k">ChannelCloseAdapter&lt;<span class="pl-smi">NginxHttpServerChannel</span>&gt;</span>() {
                <span class="pl-k">@Override</span>
                <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onClose</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">data</span>) {
                    <span class="pl-smi">Init</span><span class="pl-k">.</span>serverSentEventSubscribers<span class="pl-k">.</span>remove(data);
                    info(<span class="pl-s"><span class="pl-pds">"</span>closed <span class="pl-pds">"</span></span> <span class="pl-k">+</span> data<span class="pl-k">.</span>request()<span class="pl-k">.</span>nativeRequest());
                }
            });</pre></div>

<h2>
<a id="user-content-35-subpub--broadcast-event" class="anchor" href="#35-subpub--broadcast-event" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.5 Sub/Pub &amp; broadcast Event</h2>

<p>Suppose our Nginx instance has 3 workers (worker process not jvm_workers which is just thread number of thread pool in jvm). Now we want to provide sub/pub service. e.g.</p>

<ol>
<li>Client A connected to nginx worker A and subscribed to uri <code>/mychannel/sub</code>
</li>
<li>Client B connected to nginx worker B and subscribed to uri <code>/mychannel/sub</code>
</li>
<li>Client C connected to nginx worker C and publish a message to uri <code>/mychannel/pub</code>
</li>
</ol>

<p>So the service at endpoint of  <code>/mychannel/pub</code> must broadcast pub event to Client A and Client B.
Although for large-scale application we can use sub/pub service from Redis on nginx-clojure ,  for small-scale or medium-scale application this feature will make the dev life easier.</p>

<p>More details can be found from <a href="subpub.html">Pub/Sub Among Nginx Worker Processes</a></p>

<h2>
<a id="user-content-36-asynchronous-client-channel" class="anchor" href="#36-asynchronous-client-channel" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.6 Asynchronous Client Channel</h2>

<p>Asynchronous Client Channel is wrapper of Asynchronous Client Socket for more easier usage. 
So far Asynchronous Channel <em>cann't</em> work with thread pool mode. The Asynchronous Channel 
API is a little like Java 7 NIO.2 Asynchronous Channel and more details can be found from issue #37 and it comments
<a href="https://github.com/nginx-clojure/nginx-clojure/issues/37">Asynchronous Channel API</a>.</p>

<p>Here 's an example which is to get content from mirror.bit.edu.cn:8080 and sent it to client. </p>

<ul>
<li><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/test/clojure/nginx/clojure/asyn_channel_handlers_for_test.clj">Clojure Example</a></li>
<li><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/test/java/nginx/clojure/net/SimpleHandler4TestNginxClojureAsynChannel.java">Java Example</a></li>
</ul>

<h2>
<a id="user-content-37--about-logging" class="anchor" href="#37--about-logging" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.7  About Logging</h2>

<p>For logging with nginx-clojure  there are some ways</p>

<ol>
<li>Using System.err.print/println will write log to nginx error.log. This way is simplest but logging information will be mixed if you have more than one nginx worker.</li>
<li>Using clojure tools.logging + logback or slf4j +  logback, we can get one log file per nginx worker.</li>
</ol>

<p>e.g</p>

<p>in nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre>
 <span class="pl-k">jvm_options</span> <span class="pl-s">"-DMYPID=#{pno}"</span>;</pre></div>

<p>in logback.xml</p>

<div class="highlight highlight-text-xml"><pre>
 &lt;<span class="pl-ent">appender</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>FILE<span class="pl-pds">"</span></span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">rollingPolicy</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="pl-pds">"</span></span>&gt;
      <span class="pl-c">&lt;!-- daily rollover --&gt;</span>
      &lt;<span class="pl-ent">fileNamePattern</span>&gt;logs/myapp.%d{yyyy-MM-dd}-${MYPID}.log&lt;/<span class="pl-ent">fileNamePattern</span>&gt;
      <span class="pl-c">&lt;!-- keep 30 days' worth of history --&gt;</span>
      &lt;<span class="pl-ent">maxHistory</span>&gt;30&lt;/<span class="pl-ent">maxHistory</span>&gt;
    &lt;/<span class="pl-ent">rollingPolicy</span>&gt;

    &lt;<span class="pl-ent">encoder</span>&gt;
      &lt;<span class="pl-ent">pattern</span>&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %-10contextName %logger{36} - %msg%n&lt;/<span class="pl-ent">pattern</span>&gt;
    &lt;/<span class="pl-ent">encoder</span>&gt;
  &lt;/<span class="pl-ent">appender</span>&gt;</pre></div>

<p>Then we 'll get log files whose name just like myapp.2014-09-12-1.log,  myapp.2014-09-12-2.log.</p>

<h2>
<a id="user-content-38--sever-side-websocket" class="anchor" href="#38--sever-side-websocket" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.8  Sever Side WebSocket</h2>

<h3>
<a id="user-content-381-echo-service-example" class="anchor" href="#381-echo-service-example" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.8.1 Echo Service Example</h3>

<p>Sever Side WebSocket, like long polling/Server Sent Events, also use hijack API to get a NginxHttpServerChannel to send / receive messages. 
Here we give a echo service example.</p>

<p>In nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre><span class="pl-k">location</span> <span class="pl-en">/my-ws </span>{
        <span class="pl-k">auto_upgrade_ws</span> on;
        <span class="pl-k">content_handler_type</span> java; <span class="pl-c">###or clojure,groovy</span>
        <span class="pl-k">content_handler_name</span> <span class="pl-s">'nginx.clojure.java.WSEcho'</span>; <span class="pl-c">###or ring handler for clojure</span>
        .....
}</pre></div>

<p>The directive <code>auto_upgrade_ws on</code> is equivalent to </p>

<div class="highlight highlight-source-java"><pre>    <span class="pl-c">//NginxHttpServerChannel sc = r.hijack(true);</span>

        <span class="pl-c">//If we use nginx directive `auto_upgrade_ws on;`, these three lines can be omitted.</span>
        <span class="pl-k">if</span> (<span class="pl-k">!</span>sc<span class="pl-k">.</span>webSocketUpgrade(<span class="pl-c1">true</span>)) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }</pre></div>

<p>For clojure</p>

<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">defn</span> <span class="pl-e">echo</span> [^NginxRequest req]
         (<span class="pl-en">-&gt;</span> req
             (<span class="pl-en">hijack!</span> <span class="pl-c1">true</span>)
             (<span class="pl-en">add-listener!</span> { <span class="pl-c1">:on-open</span> (<span class="pl-k">fn</span> [ch] (<span class="pl-en">log</span> <span class="pl-s"><span class="pl-pds">"</span>uri:%s, on-open!<span class="pl-pds">"</span></span> (<span class="pl-c1">:uri</span> req)))
                              <span class="pl-c1">:on-message</span> (<span class="pl-k">fn</span> [ch msg rem?] (<span class="pl-en">send!</span> ch msg (<span class="pl-en">not</span> rem?) <span class="pl-c1">false</span>))
                              <span class="pl-c1">:on-close</span> (<span class="pl-k">fn</span> [ch reason] (<span class="pl-en">log</span> <span class="pl-s"><span class="pl-pds">"</span>uri:%s, on-close:%s<span class="pl-pds">"</span></span> (<span class="pl-c1">:uri</span> req) reason))
                              <span class="pl-c1">:on-error</span> (<span class="pl-k">fn</span> [ch error] (<span class="pl-en">log</span> <span class="pl-s"><span class="pl-pds">"</span>uri:%s, on-error:%s<span class="pl-pds">"</span></span> (<span class="pl-c1">:uri</span> req)  error))
                             })))</pre></div>

<p>For java </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">package</span> <span class="pl-smi">nginx.clojure.java</span>;

<span class="pl-k">import</span> <span class="pl-smi">java.io.IOException</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.nio.ByteBuffer</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.Map</span>;

<span class="pl-k">import</span> <span class="pl-smi">nginx.clojure.MessageAdapter</span>;
<span class="pl-k">import</span> <span class="pl-smi">nginx.clojure.NginxClojureRT</span>;
<span class="pl-k">import</span> <span class="pl-smi">nginx.clojure.NginxHttpServerChannel</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">WSEcho</span> <span class="pl-k">implements</span> <span class="pl-e">NginxJavaRingHandler</span> {

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-k">Object</span>[] <span class="pl-en">invoke</span>(<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Object</span>&gt;</span> <span class="pl-v">request</span>) {
        <span class="pl-smi">NginxJavaRequest</span> r <span class="pl-k">=</span> (<span class="pl-smi">NginxJavaRequest</span>)request;
        <span class="pl-smi">NginxHttpServerChannel</span> sc <span class="pl-k">=</span> r<span class="pl-k">.</span>hijack(<span class="pl-c1">true</span>);
        sc<span class="pl-k">.</span>addListener(sc, <span class="pl-k">new</span> <span class="pl-k">MessageAdapter&lt;<span class="pl-smi">NginxHttpServerChannel</span>&gt;</span>() {
            <span class="pl-k">int</span> total <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onOpen</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">data</span>) {
                <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>debug(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onOpen!<span class="pl-pds">"</span></span>);
            }

            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onTextMessage</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">sc</span>, <span class="pl-smi">String</span> <span class="pl-v">message</span>, <span class="pl-k">boolean</span> <span class="pl-v">remaining</span>) <span class="pl-k">throws</span> <span class="pl-smi">IOException</span> {
                <span class="pl-k">if</span> (<span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>isDebugEnabled()) {
                    <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>debug(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onTextMessage: msg=%s, rem=%s<span class="pl-pds">"</span></span>, message, remaining);
                }
                total <span class="pl-k">+=</span> message<span class="pl-k">.</span>length();
                sc<span class="pl-k">.</span>send(message, <span class="pl-k">!</span>remaining, <span class="pl-c1">false</span>);
            }

            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onBinaryMessage</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">sc</span>, <span class="pl-smi">ByteBuffer</span> <span class="pl-v">message</span>, <span class="pl-k">boolean</span> <span class="pl-v">remining</span>) <span class="pl-k">throws</span> <span class="pl-smi">IOException</span> {
                <span class="pl-k">if</span> (<span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>isDebugEnabled()) {
                    <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>debug(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onBinaryMessage: msg=%s, rem=%s, total=%d<span class="pl-pds">"</span></span>, message, remining, total);
                }
                total <span class="pl-k">+=</span> message<span class="pl-k">.</span>remaining();
                sc<span class="pl-k">.</span>send(message, <span class="pl-k">!</span>remining, <span class="pl-c1">false</span>);
            }

            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onClose</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">req</span>, <span class="pl-k">long</span> <span class="pl-v">status</span>, <span class="pl-smi">String</span> <span class="pl-v">reason</span>) {
                <span class="pl-k">if</span> (<span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>isDebugEnabled()) {
                  <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>info(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onClose2: total=%d, status=%d, reason=%s<span class="pl-pds">"</span></span>, total, status, reason);
                }
            }

            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onError</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">data</span>, <span class="pl-k">long</span> <span class="pl-v">status</span>) {
                <span class="pl-k">if</span> (<span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>isDebugEnabled()) {
                      <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>info(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onError: total=%d, status=%d<span class="pl-pds">"</span></span>, total, status);
                    }
            }

        });
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }

}</pre></div>

<h3>
<a id="user-content-381-use-access-handler-for-websocket-security" class="anchor" href="#381-use-access-handler-for-websocket-security" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.8.1 Use Access Handler For WebSocket Security</h3>

<p>In below example we return 404 for non WebSocket request </p>

<div class="highlight highlight-source-nginx"><pre><span class="pl-k">location</span> <span class="pl-en">/my-ws </span>{
        <span class="pl-k">auto_upgrade_ws</span> on;
        <span class="pl-k">access_handler_type</span> java;
        <span class="pl-k">access_handler_name</span> <span class="pl-s">'my.WSAccessHandler'</span>;
        <span class="pl-k">content_handler_type</span> java; <span class="pl-c">###or clojure,groovy</span>
        <span class="pl-k">content_handler_name</span> <span class="pl-s">'nginx.clojure.java.WSEcho'</span>; <span class="pl-c">###or ring handler for clojure</span>
        .....
}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">package</span> <span class="pl-smi">my</span>;
<span class="pl-k">import</span> <span class="pl-smi">nginx.clojure.java.NginxJavaRingHandler</span>;
<span class="pl-k">import static</span> <span class="pl-smi">nginx.clojure.java.Constants.*</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">WSAccessHandler</span> <span class="pl-k">implements</span> <span class="pl-e">NginxJavaRingHandler</span> {
  <span class="pl-k">public</span> <span class="pl-k">Object</span>[] <span class="pl-en">invoke</span>(<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Object</span>&gt;</span> <span class="pl-v">request</span>) {
    <span class="pl-k">if</span> (<span class="pl-c1">GET</span> <span class="pl-k">!=</span> request<span class="pl-k">.</span>get(<span class="pl-s"><span class="pl-pds">"</span>request-method<span class="pl-pds">"</span></span>) 
        <span class="pl-k">||</span> <span class="pl-k">!</span><span class="pl-s"><span class="pl-pds">"</span>websocket<span class="pl-pds">"</span></span><span class="pl-k">.</span>equals(request<span class="pl-k">.</span>get(<span class="pl-s"><span class="pl-pds">"</span>headers<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>get(<span class="pl-s"><span class="pl-pds">"</span>upgrade<span class="pl-pds">"</span></span>))) {
      <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Object</span>[]{<span class="pl-c1">404</span>, <span class="pl-c1">null</span>, <span class="pl-c1">null</span>};
    }
    <span class="pl-k">return</span> <span class="pl-c1">PHASE_DONE</span>;
  }
}
</pre></div>

<h2>
<a id="user-content-39--java-standard-restful-web-services-with-jersey" class="anchor" href="#39--java-standard-restful-web-services-with-jersey" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.9  Java standard RESTful web services with Jersey</h2>

<p>in nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre>      <span class="pl-k">location</span> <span class="pl-en">/jersey </span>{

          <span class="pl-k">content_handler_type</span> java;
          <span class="pl-k">content_handler_name</span> <span class="pl-s">'nginx.clojure.bridge.NginxBridgeHandler'</span>;
          <span class="pl-k">content_handler_property</span> system.m2rep <span class="pl-s">'/home/who/.m2/repository'</span>;

          <span class="pl-c">##we can put jars into some dir then all of their path will be appended into the classpath</span>
          <span class="pl-c">#content_handler_property bridge.lib.dirs 'my-jersey-libs-dir:myother-dir';</span>

          <span class="pl-c">##the path of nginx-jersey-x.x.x.jar must be included in the below classpath or one of above #{bridge.lib.dirs}</span>
          <span class="pl-c">##we can use maven assembly plugin to get a all-in-one jar file with dependencies, e.g. json-jackson-example-with-dependencies.jar.</span>
          <span class="pl-k">content_handler_property</span> bridge.lib.cp <span class="pl-s">'jars/nginx-jersey-0.1.0.jar:myjars/json-jackson-example-with-dependencies.jar'</span>;
          <span class="pl-k">content_handler_property</span> bridge.imp <span class="pl-s">'nginx.clojure.jersey.NginxJerseyContainer'</span>;

          <span class="pl-c">##aplication path usually it is the same with nginx location </span>
          <span class="pl-k">content_handler_property</span> jersey.app.path <span class="pl-s">'/jersey'</span>;

          <span class="pl-c">##application resources which can be either of JAX-RS resources, providers</span>
          <span class="pl-k">content_handler_property</span> jersey.app.resources <span class="pl-s">'</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.EmptyArrayResource,</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.NonJaxbBeanResource,</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.CombinedAnnotationResource,</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.MyObjectMapperProvider,</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.ExceptionMappingTestResource,</span>
<span class="pl-s">                org.glassfish.jersey.jackson.JacksonFeature</span>
<span class="pl-s">          '</span>;
          <span class="pl-k">gzip</span><span class="pl-c1"> on</span>;
          <span class="pl-k">gzip_types</span> application/javascript application/xml text/plain text/css <span class="pl-s">'text/html;charset=UTF-8'</span>; 
      }</pre></div>

<p>All sources about this example can be found from jersey github repository 's example <a href="https://github.com/jersey/jersey/tree/2.17/examples/json-jackson/src/main/java/org/glassfish/jersey/examples/jackson">json-jackson</a>.</p>

<p>then we test the JAX-RS services by curl</p>

<div class="highlight highlight-source-shell"><pre>$ curl  -v http://localhost:8080/jersey/emptyArrayResource
<span class="pl-k">&gt;</span> GET /jersey/emptyArrayResource HTTP/1.1
<span class="pl-k">&gt;</span> User-Agent: curl/7.35.0
<span class="pl-k">&gt;</span> Host: localhost:8080
<span class="pl-k">&gt;</span> Accept: <span class="pl-k">*</span>/<span class="pl-k">*</span>
<span class="pl-k">&gt;</span> 
<span class="pl-k">&lt;</span> HTTP/1.1 200 OK
<span class="pl-k">&lt;</span> Date: Sat, 23 May 2015 17:47:14 GMT
<span class="pl-k">&lt;</span> Content-Type: application/json
<span class="pl-k">&lt;</span> Transfer-Encoding: chunked
<span class="pl-k">&lt;</span> Connection: keep-alive
<span class="pl-k">*</span> Server nginx-clojure is not blacklisted
<span class="pl-k">&lt;</span> Server: nginx-clojure
<span class="pl-k">&lt;</span> 
{
  <span class="pl-s"><span class="pl-pds">"</span>emtpyArray<span class="pl-pds">"</span></span> <span class="pl-c1">:</span> [ ]
}</pre></div>

<div class="highlight highlight-source-shell"><pre>$ curl -v http://localhost:8080/jersey/nonJaxbResource
<span class="pl-k">&gt;</span> GET /jersey/nonJaxbResource HTTP/1.1
<span class="pl-k">&gt;</span> User-Agent: curl/7.35.0
<span class="pl-k">&gt;</span> Host: localhost:8080
<span class="pl-k">&gt;</span> Accept: <span class="pl-k">*</span>/<span class="pl-k">*</span>
<span class="pl-k">&gt;</span> 
<span class="pl-k">&lt;</span> HTTP/1.1 200 OK
<span class="pl-k">&lt;</span> Date: Sat, 23 May 2015 17:46:17 GMT
<span class="pl-k">&lt;</span> Content-Type: application/javascript
<span class="pl-k">&lt;</span> Transfer-Encoding: chunked
<span class="pl-k">&lt;</span> Connection: keep-alive
<span class="pl-k">*</span> Server nginx-clojure is not blacklisted
<span class="pl-k">&lt;</span> Server: nginx-clojure
<span class="pl-k">&lt;</span> 
callback({
  <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span> <span class="pl-c1">:</span> <span class="pl-s"><span class="pl-pds">"</span>non-JAXB-bean<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span> <span class="pl-c1">:</span> <span class="pl-s"><span class="pl-pds">"</span>I am not a JAXB bean, just an unannotated POJO<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>array<span class="pl-pds">"</span></span> <span class="pl-c1">:</span> [ 1, 1, 2, 3, 5, 8, 13, 21 ]
<span class="pl-k">*</span> Connection <span class="pl-c">#0 to host localhost left intact</span>
})</pre></div>

<h2>
<a id="user-content-310-embeding-tomcat" class="anchor" href="#310-embeding-tomcat" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.10 Embeding Tomcat</h2>

<h3>
<a id="user-content-which-version" class="anchor" href="#which-version" aria-hidden="true"><span class="octicon octicon-link"></span></a>Which Version?</h3>

<table>
<thead>
<tr>
<th>Apache Tomcat version</th>
<th>Nginx-Clojure version</th>
<th>Nginx-Tomcat8 version</th>
</tr>
</thead>
<tbody>
<tr>
<td>8.0.20</td>
<td>&gt;=0.4.x</td>
<td>0.1.x</td>
</tr>
<tr>
<td>8.0.23,8.0.24</td>
<td>&gt;=0.4.x</td>
<td>0.2.x</td>
</tr>
</tbody>
</table>

<h3>
<a id="user-content-get-jar-file" class="anchor" href="#get-jar-file" aria-hidden="true"><span class="octicon octicon-link"></span></a>Get Jar File</h3>

<p>We can get the released version from <a href="https://clojars.org/nginx-clojure/nginx-tomcat8">clojars</a> or 
the jar in <a href="https://sourceforge.net/projects/nginx-clojure/files/">nginx-clojure binary release</a> </p>

<p>For get the latest version from the github source</p>

<div class="highlight highlight-source-shell"><pre>git clone https://github.com/nginx-clojure/nginx-clojure
<span class="pl-c1">cd</span> nginx-clojure/nginx-tomcat8
lein jar</pre></div>

<h3>
<a id="user-content-configuration" class="anchor" href="#configuration" aria-hidden="true"><span class="octicon octicon-link"></span></a>Configuration</h3>

<p>in nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre>      <span class="pl-k">location</span> <span class="pl-en">/ </span>{

          <span class="pl-k">content_handler_type</span> java;
          <span class="pl-k">content_handler_name</span> <span class="pl-s">'nginx.clojure.bridge.NginxBridgeHandler'</span>;

          <span class="pl-c">##Tomcat 8 installation path</span>
          <span class="pl-k">content_handler_property</span> system.catalina.home <span class="pl-s">'/home/who/share/apps/apache-tomcat-8.0.20'</span>;
          <span class="pl-k">content_handler_property</span> system.catalina.base <span class="pl-s">'#{catalina.home}'</span>;

          <span class="pl-c">##uncomment this to disable websocket perframe-compression</span>
          <span class="pl-c">#content_handler_property system.org.apache.tomcat.websocket.DISABLE_BUILTIN_EXTENSIONS true;</span>

          <span class="pl-c">##log manger</span>
          <span class="pl-k">content_handler_property</span> system.java.util.logging.manager <span class="pl-s">'org.apache.juli.ClassLoaderLogManager'</span>;

          <span class="pl-c">## all jars or direct child directories will be appended into the classpath of this bridge handler's class-loader</span>
          <span class="pl-k">content_handler_property</span> bridge.lib.dirs <span class="pl-s">'#{catalina.home}/lib:#{catalina.home}/bin'</span>;

          <span class="pl-c">##set nginx tomcat8 bridge implementation jar and other jars can also be appended here</span>
          <span class="pl-k">content_handler_property</span> bridge.lib.cp <span class="pl-s">'my-jar-path/nginx-tomcat8-x.x.x.jar'</span>;

          <span class="pl-c">##The implementation class of nginx-clojure bridge handler for Tomcat 8</span>
          <span class="pl-k">content_handler_property</span> bridge.imp <span class="pl-s">'nginx.clojure.tomcat8.NginxTomcatBridge'</span>;

          <span class="pl-c">##ignore nginx filter, default is false</span>
          <span class="pl-c">#content_handler_property ignoreNginxFilter false;</span>

          <span class="pl-c">##when dispatch is false tomcat servlet will be executed in main thread.By default dispatch is false</span>
          <span class="pl-c">##when use websocket with tomcat it must be set true otherwise maybe deadlock will happen.</span>
          <span class="pl-c">#content_handler_property dispatch false;</span>

          <span class="pl-k">gzip</span><span class="pl-c1"> on</span>;
          <span class="pl-k">gzip_types</span> text/plain text/css <span class="pl-s">'text/html;charset=ISO-8859-1'</span> <span class="pl-s">'text/html;charset=UTF-8'</span>; 

          <span class="pl-c">##if for small message, e.g. small json/websocket message write_page_size can set to be a small value</span>
          <span class="pl-c">#write_page_size 2k;</span>
      }</pre></div>

<h2>
<a id="user-content-session-management" class="anchor" href="#session-management" aria-hidden="true"><span class="octicon octicon-link"></span></a>Session Management</h2>

<p>If <code>worker_processes</code> &gt; 1 there will be more than one jvm instances viz. more tomcat instances so to get synchronized session information we can not use the default tomcat session manger.
Instead we may consider to use either of</p>

<ol>
<li>Cookie based Session Store  viz. storing all session attribute information into cookies.</li>
<li>Shared HashMap among processes in the same machine ,e.g. <a href="https://github.com/OpenHFT/Chronicle-Map">Chronicle Map</a>
</li>
<li>External Session Store,  e.g.  Redis / MySQL / Memcached Session Store</li>
</ol>

<h3>
<a id="user-content-for-performance" class="anchor" href="#for-performance" aria-hidden="true"><span class="octicon octicon-link"></span></a>For Performance</h3>

<h4>
<a id="user-content-disable-tomcat-access-log" class="anchor" href="#disable-tomcat-access-log" aria-hidden="true"><span class="octicon octicon-link"></span></a>Disable Tomcat Access Log</h4>

<p>When we need access log , use Nginx access log instead of Tomcat access log.</p>

<p>In server.xml comment AccessLogValve configuration to disable Tomcat access log.</p>

<div class="highlight highlight-text-xml"><pre><span class="pl-c">&lt;!--</span>
<span class="pl-c">        &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"</span>
<span class="pl-c">               prefix="localhost_access_log" suffix=".txt"</span>
<span class="pl-c">               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;</span>
<span class="pl-c">--&gt;</span></pre></div>

<h4>
<a id="user-content-disable-logging-to-console" class="anchor" href="#disable-logging-to-console" aria-hidden="true"><span class="octicon octicon-link"></span></a>Disable logging to console</h4>

<p>Because Tomcat console log is duplicate with other log such as catalina log, manager log ,etc, so it can be disabled.
In conf/logging.properties remove all <code>java.util.logging.ConsoleHandler</code></p>

<div class="highlight highlight-source-shell"><pre>handlers = 1catalina.org.apache.juli.AsyncFileHandler, 2localhost.org.apache.juli.AsyncFileHandler, 3manager.org.apache.juli.AsyncFileHandler, 4host-manager.org.apache.juli.AsyncFileHandler

.handlers = 1catalina.org.apache.juli.AsyncFileHandler</pre></div>

<h4>
<a id="user-content-dont-enable-tomcat-compression" class="anchor" href="#dont-enable-tomcat-compression" aria-hidden="true"><span class="octicon octicon-link"></span></a>Don't Enable Tomcat Compression</h4>

<p>By default compression is off , do not turn it on.</p>

<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">Connector</span> <span class="pl-e">port</span>=<span class="pl-s"><span class="pl-pds">"</span>8080<span class="pl-pds">"</span></span> <span class="pl-e">protocol</span>=<span class="pl-s"><span class="pl-pds">"</span>HTTP/1.1<span class="pl-pds">"</span></span> <span class="pl-e">compression</span>=<span class="pl-s"><span class="pl-pds">"</span>off<span class="pl-pds">"</span></span></pre></div>

<p>If we need compression use nginx gzip filter instead. e.g. In nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre><span class="pl-k">location</span> <span class="pl-en">/examples </span>{
    <span class="pl-k">gzip</span><span class="pl-c1"> on</span>;
    <span class="pl-k">gzip_types</span> text/plain text/css <span class="pl-s">'text/html;charset=ISO-8859-1'</span> <span class="pl-s">'text/html;charset=UTF-8'</span>; 
}</pre></div>

<p><code>gzip</code> can also appear at http, server blocks. More details can be found <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">HERE</a></p>

<h2>
<a id="user-content-311-more-about-nginx-worker-process" class="anchor" href="#311-more-about-nginx-worker-process" aria-hidden="true"><span class="octicon octicon-link"></span></a>3.11 More about Nginx Worker Process</h2>

<p>The number of Nginx worker processes can be configured by nginx directive <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes">worker_processes</a>.
e.g. We use 8 Nginx worker processes:</p>

<div class="highlight highlight-source-nginx"><pre><span class="pl-k">worker_processes</span> <span class="pl-s">8</span>;</pre></div>

<p>Because a JVM instance will be embeded into per Nginx worker process so if there are more than one Nginx worker prcocesses there will be more than one JVM instances.
So if we want to get synchronized session information we can not use the default tomcat session manger. Instead we may consider to use either of </p>

<ol>
<li>Cookie based Session Store  viz. storing all session attribute information into cookies.</li>
<li>Shared HashMap among processes in the same machine ,e.g. <a href="https://github.com/OpenHFT/Chronicle-Map">Chronicle Map</a>
</li>
<li>External Session Store,  e.g.  Redis / MySQL / Memcached Session Store</li>
</ol>

<p>When there are more than one Nginx worker prcocesses sub/pub services also need to be taken care of. Subscribers may connect to JVM instances which maybe are different
with the JVM instance which the publisher send message to. So we need to use <a href="more.html#35-subpub--broadcast-event">broadcast API</a> from nginx-clojure
and broadcast message to all Nginx worker prcocesses.</p>
