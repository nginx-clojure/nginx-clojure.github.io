<h1>
<a id="user-content-3-more-about-nginx-clojure" class="anchor" href="#3-more-about-nginx-clojure" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3. More about Nginx-Clojure</h1>

<h2>
<a id="user-content-30-more-about-apis" class="anchor" href="#30-more-about-apis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.0 More about APIs</h2>

<h3>
<a id="user-content-request--response" class="anchor" href="#request--response" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Request &amp; Response</h3>

<p>For Clojure the request map and response map are defined by the ring SEPC at <a href="https://github.com/ring-clojure/ring/blob/master/SPEC">https://github.com/ring-clojure/ring/blob/master/SPEC</a> .</p>

<p>For Java/Groovy, the request map contains serveral parts:</p>

<ol>
<li>server-port (Required, Integer) The port on which the request is being handled.</li>
<li>server-name (Required, String) The resolved server name, or the server IP address.</li>
<li>remote-addr (Required, String) The IP address of the client or the last proxy that sent the request.</li>
<li>uri (Required, String) The request URI, excluding the query string and the "?" separator. Must start with "/".</li>
<li>query-string (Optional, String) The query string, if present.</li>
<li>scheme (Required, String) The transport protocol, must be http or https.</li>
<li>request-method (Required, String) The HTTP request method, must be a lowercase keyword corresponding to a HTTP request method, such as :get or :post.</li>
<li>content-type <strong>DEPRECATED</strong> (Optional, String) The MIME type of the request body, if known.</li>
<li>content-length <strong>DEPRECATED</strong> (Optional, Integer) The number of bytes in the request body, if known.</li>
<li>character-encoding <strong>DEPRECATED</strong> (Optional, String) The name of the character encoding used in the request body, if known.</li>
<li>sl-client-cert (Optional, X509Certificate) The SSL client certificate, if supplied. This value  is not <strong>supported</strong> yet.</li>
<li>headers (Required, Map) A map of header name Strings to corresponding header value Strings.</li>
<li>body (Optional, InputStream) An InputStream for the request body, if present.</li>
</ol>

<p>The return response is an array of object, e.g</p>

<div class="highlight highlight-source-java"><pre>
 [<span class="pl-c1">200</span>, <span class="pl-c">//http status 200 </span>
   <span class="pl-smi">ArrayMap</span><span class="pl-k">.</span>create(<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text/html<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span><span class="pl-pds">"</span></span> ), <span class="pl-c">//headers map</span>
   <span class="pl-s"><span class="pl-pds">"</span>Hello, Java &amp; Nginx!<span class="pl-pds">"</span></span> <span class="pl-c">//response body can be string, File or Array/Collection of string or File ]; </span></pre></div>

<blockquote>
<p>Note that if the rewrite/access handler returns phase-done (Clojure) or Constants.PHRASE_DONE (Groovy/Java), nginx will continue to next phases (e.g. invoke proxy_pass or content ring handler). If the rewrite handler returns a general response, nginx will send this response to the client and stop to continue to next phases.</p>
</blockquote>

<h2>
<a id="user-content-31-handle-multiple-coroutine-based-sockets-parallel" class="anchor" href="#31-handle-multiple-coroutine-based-sockets-parallel" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.1 Handle Multiple Coroutine Based Sockets Parallel</h2>

<p>Sometimes we need to invoke serveral remote services before completing the ring  response. For better performance we need a way to handle multiple sockets parallel in sub coroutines.</p>

<p>e.g. fetch two page parallel by clj-http</p>

<div class="highlight highlight-source-clojure"><pre>   (<span class="pl-k">let</span> [[r1, r2] 
                (<span class="pl-en">co-pvalues</span> (<span class="pl-en">client/get</span> <span class="pl-s"><span class="pl-pds">"</span>http://service1-url<span class="pl-pds">"</span></span>) 
                            (<span class="pl-en">client/get</span> <span class="pl-s"><span class="pl-pds">"</span>http://service2-url<span class="pl-pds">"</span></span>))]
    <span class="pl-c">;println bodies of two remote response</span>
    (<span class="pl-en">println</span> (<span class="pl-en">str</span> (<span class="pl-c1">:body</span> r1) <span class="pl-s"><span class="pl-pds">"</span>====<span class="pl-cce">\n</span><span class="pl-pds">"</span></span> (<span class="pl-c1">:body</span> r2) ))</pre></div>

<p>Here <code>co-pvalues</code> is also non-blocking and coroutine based. In fact it will create two sub coroutines to handle two sockets.</p>

<p>For Java/Groovy, we can use <code>NginxClojureRT.coBatchCall</code> to do the same thing. Here's a simple example for Groovy.</p>

<div class="highlight highlight-source-groovy"><pre>     <span class="pl-k">def</span> (r1, r2) <span class="pl-k">=</span> <span class="pl-k">NginxClojureRT</span><span class="pl-k">.</span>coBatchCall( 
       {<span class="pl-s"><span class="pl-pds">"</span>http://mirror.bit.edu.cn/apache/httpcomponents/httpclient/<span class="pl-pds">"</span></span><span class="pl-k">.</span>toURL()<span class="pl-k">.</span>text},
       {<span class="pl-s"><span class="pl-pds">"</span>http://mirror.bit.edu.cn/apache/httpcomponents/httpcore/<span class="pl-pds">"</span></span><span class="pl-k">.</span>toURL()<span class="pl-k">.</span>text})
     <span class="pl-k">return</span> [<span class="pl-c1">200</span>, [<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>text/html<span class="pl-pds">"</span></span>], r1 <span class="pl-k">+</span> r2];
</pre></div>

<h2>
<a id="user-content-32-shared-map-among-nginx-workers" class="anchor" href="#32-shared-map-among-nginx-workers" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.2 Shared Map among Nginx Workers</h2>

<p>See <a href="sharedmap.html">Shared Map &amp; Session Store</a>.</p>

<h2>
<a id="user-content-33-user-defined-http-method" class="anchor" href="#33-user-defined-http-method" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.3 User Defined Http Method</h2>

<p>Some web services need a user defined http request method to define special operations beyond standard http request methods. </p>

<p>e.g. We use <code>MYUPLOAD</code> to upload a file and overwrite the one if it exists.  The <code>curl</code> command could be </p>

<div class="highlight highlight-source-shell"><pre>curl   -v  -X MYUPLOAD  --upload-file post-test-data \
<span class="pl-s"><span class="pl-pds">"</span>http://localhost:8080/myservice<span class="pl-pds">"</span></span> </pre></div>

<p>In the nginx.conf, we can use <code>always_read_body on;</code> to force nginx to read http body.</p>

<div class="highlight highlight-source-nginx"><pre>
<span class="pl-k">location</span> <span class="pl-en">/myservice </span>{
         <span class="pl-k">handler_type</span> <span class="pl-s">'clojure'</span>;
         <span class="pl-k">always_read_body</span> on;
         <span class="pl-k">content_handler_code</span> <span class="pl-s">'....'</span>;
}
</pre></div>

<h2>
<a id="user-content-34-server-channel-for-long-polling--server-sent-events-sse" class="anchor" href="#34-server-channel-for-long-polling--server-sent-events-sse" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.4 Server Channel for Long Polling &amp; Server Sent Events (SSE)</h2>

<p>Since v0.2.5, nginx-clojure provides a union form of <a href="https://github.com/nginx-clojure/nginx-clojure/issues/41">hijack API</a> to work with Long Polling &amp; Server Sent Events (SSE).</p>

<h3>
<a id="user-content-hijack-the-request" class="anchor" href="#hijack-the-request" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Hijack the Request</h3>

<p>We can hijack the request to get a http server channel to send some messages later. After hijacking the return result from ring handler, it will be ignored so we can finely control when &amp; what to be sent to the client.</p>

<p>For Clojure</p>

<div class="highlight highlight-source-clojure"><pre>
(<span class="pl-k">fn</span> my-handler[req]
         (<span class="pl-k">let</span> [ch (<span class="pl-en">hijack!</span> req <span class="pl-c1">true</span>)]
          <span class="pl-c">;;; save channel ch to use it later     </span>
))</pre></div>

<p>The complete <code>hijack!</code> description is below </p>

<div class="highlight highlight-source-clojure"><pre>
(<span class="pl-k">defn</span> <span class="pl-e">hijack!</span> 
  <span class="pl-s"><span class="pl-pds">"</span>Hijack a nginx request and return a server channel.</span>
<span class="pl-s">   After being hijacked, the ring handler's result will be ignored.</span>
<span class="pl-s">   If ignore-nginx-filter? is true all data output to channel won't be filtered</span>
<span class="pl-s">   by any nginx HTTP header/body filters such as gzip filter, chucked filter, etc.</span>
<span class="pl-s">   We can use this function to implement long polling / Server Sent Events (SSE) easily.<span class="pl-pds">"</span></span>
  [^NginxRequest req ignore-nginx-filter?])</pre></div>

<p>For Java</p>

<div class="highlight highlight-source-java"><pre>
    <span class="pl-k">public</span>  <span class="pl-k">class</span> <span class="pl-en">MyHandler</span> <span class="pl-k">implements</span> <span class="pl-e">NginxJavaRingHandler</span> {

        <span class="pl-k">@Override</span>
        <span class="pl-k">public</span> <span class="pl-k">Object</span>[] <span class="pl-en">invoke</span>(<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Object</span>&gt;</span> <span class="pl-v">request</span>) {
            <span class="pl-smi">NginxJavaRequest</span> r <span class="pl-k">=</span> ((<span class="pl-smi">NginxJavaRequest</span>)request);
            <span class="pl-smi">NginxHttpServerChannel</span> channel <span class="pl-k">=</span> r<span class="pl-k">.</span>handler()<span class="pl-k">.</span>hijack(r, <span class="pl-c1">true</span>);           
            <span class="pl-c">//save channel ch to use it later    </span>
            <span class="pl-c">//nginx-clojure will ignore this return because we have hijacked the request.</span>
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }
    }</pre></div>

<p>The complete java doc about hijack is below</p>

<div class="highlight highlight-source-java"><pre>    <span class="pl-c">/**</span>
<span class="pl-c">     * Get a hijacked Server Channel used to send message later typically in another thread</span>
<span class="pl-c">     * If ignoreFilter is true all data output to channel won't be filtered</span>
<span class="pl-c">     * by any nginx HTTP header/body filters such as gzip filter, chucked filter, etc.</span>
<span class="pl-c">     * @param req the request object</span>
<span class="pl-c">     * @param ignoreFilter whether we need ignore nginx filter or not.</span>
<span class="pl-c">     * @return hijacked channel used to send message later</span>
<span class="pl-c">     */</span>
    <span class="pl-k">public</span> <span class="pl-smi">NginxHttpServerChannel</span> hijack(<span class="pl-smi">NginxRequest</span> req, <span class="pl-k">boolean</span> ignoreFilter);</pre></div>

<h3>
<a id="user-content-send-a-complete-response-for-long-polling" class="anchor" href="#send-a-complete-response-for-long-polling" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Send a Complete Response for Long Polling</h3>

<p>When an event happens which produces a complete response it must be sent to the Long Polling request client. We can use <code>send-response!</code>(Clojure) or sendResponse (Java/Groovy) to send a complete response. This action is non-blocking and after completion the channel will be closed automatically.</p>

<p>For Clojure</p>

<div class="highlight highlight-source-clojure"><pre>
(<span class="pl-en">send-response!</span> ch {<span class="pl-c1">:status</span> <span class="pl-c1">200</span>, <span class="pl-c1">:headers</span> {<span class="pl-s"><span class="pl-pds">"</span>content-type<span class="pl-pds">"</span></span> <span class="pl-s"><span class="pl-pds">"</span>text/plain<span class="pl-pds">"</span></span>}, <span class="pl-c1">:body</span> data}</pre></div>

<p>For Java</p>

<div class="highlight highlight-source-java"><pre>
channel<span class="pl-k">.</span>sendResponse(<span class="pl-k">new</span> <span class="pl-smi">Object</span>[] { <span class="pl-c1">NGX_HTTP_OK</span>,
                <span class="pl-smi">ArrayMap</span><span class="pl-k">.</span>create(<span class="pl-s"><span class="pl-pds">"</span>content-type<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text/json<span class="pl-pds">"</span></span>),
                message});</pre></div>

<h3>
<a id="user-content-send-messages-for-server-sent-events-sse" class="anchor" href="#send-messages-for-server-sent-events-sse" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Send Messages for Server Sent Events (SSE)</h3>

<p>First we can use <code>send-headers!</code>(Clojure) or <code>sendHeaders</code> (Java/Groovy) to send a SSE header. Then we
can use <code>send!</code> (Clojure) or <code>send</code> (Java/Groovy) to send later messages. The last two parameters of a send
function is used to flush a message or close the channel after sending the current message.</p>

<p>For Clojure:</p>

<div class="highlight highlight-source-clojure"><pre>
 <span class="pl-c">;;; send header and retry hint of SSE</span>
 (<span class="pl-en">send-header!</span> ch <span class="pl-c1">200</span> {<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text/event-stream<span class="pl-pds">"</span></span>} <span class="pl-c1">false</span> <span class="pl-c1">false</span>)
 (<span class="pl-en">send!</span> ch <span class="pl-s"><span class="pl-pds">"</span>retry: 4500<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span> <span class="pl-c1">true</span> <span class="pl-c1">false</span>)

 <span class="pl-c">;;; send the message and do flush </span>
 (<span class="pl-en">send!</span> ch <span class="pl-s"><span class="pl-pds">"</span>data: Are you ok?<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span> <span class="pl-c1">true</span> <span class="pl-c1">false</span>)

 <span class="pl-c">;;; send the last message, identical to (send! ch data true false) (close! ch)</span>
 (<span class="pl-en">send!</span> ch <span class="pl-s"><span class="pl-pds">"</span>data: Bye, bye.<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span> <span class="pl-c1">true</span> <span class="pl-c1">true</span>)
</pre></div>

<p>For Java:</p>

<div class="highlight highlight-source-java"><pre>
<span class="pl-c">//send header and retry hint of SSE</span>
channel<span class="pl-k">.</span>sendHeader(<span class="pl-c1">200</span>, <span class="pl-smi">ArrayMap</span><span class="pl-k">.</span>create(<span class="pl-s"><span class="pl-pds">"</span>Content-Type<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>text/event-stream<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>entrySet(), <span class="pl-c1">true</span>, <span class="pl-c1">false</span>);
channel<span class="pl-k">.</span>send(<span class="pl-s"><span class="pl-pds">"</span>retry: 4500<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>, <span class="pl-c1">false</span>);

<span class="pl-c">//send the message and do flush </span>
channel<span class="pl-k">.</span>send(<span class="pl-s"><span class="pl-pds">"</span>data: Are you ok?<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>, <span class="pl-c1">false</span>)

<span class="pl-c">//send the last message, identical to channel.send(data true false); channel.close();</span>
channel<span class="pl-k">.</span>send(<span class="pl-s"><span class="pl-pds">"</span>data: Bye, bye.<span class="pl-cce">\r\n</span><span class="pl-pds">"</span></span>, <span class="pl-c1">true</span>, <span class="pl-c1">true</span>)</pre></div>

<h3>
<a id="user-content-listener-about-the-closed-event-of-channel" class="anchor" href="#listener-about-the-closed-event-of-channel" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Listener about the Closed Event of Channel</h3>

<p>A closed event will happen immediately when a channel is closed by either of these three cases:</p>

<ul>
<li>channel close function/method is invoked on this channel, e.g. (close! ch)</li>
<li>inner unrecoverable error happens with this channel, e.g. not enough memory to read/write</li>
<li>remote client connection is closed or broken.</li>
</ul>

<p>For Clojure</p>

<div class="highlight highlight-source-clojure"><pre>
(<span class="pl-en">on-close!</span> ch {<span class="pl-c1">:ch</span> ch <span class="pl-c1">:desc</span> <span class="pl-s"><span class="pl-pds">"</span>this is an event attachement<span class="pl-pds">"</span></span>}
 (<span class="pl-en">fn[att]</span> (<span class="pl-en">info</span> <span class="pl-s"><span class="pl-pds">"</span>closed channel from request :<span class="pl-pds">"</span></span> (<span class="pl-en">.request</span> (<span class="pl-c1">:ch</span> att)))))</pre></div>

<p>For Java</p>

<div class="highlight highlight-source-java"><pre>
channel<span class="pl-k">.</span>addListener(channel, <span class="pl-k">new</span> <span class="pl-k">ChannelCloseAdapter&lt;<span class="pl-smi">NginxHttpServerChannel</span>&gt;</span>() {
                <span class="pl-k">@Override</span>
                <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onClose</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">data</span>) {
                    <span class="pl-smi">Init</span><span class="pl-k">.</span>serverSentEventSubscribers<span class="pl-k">.</span>remove(data);
                    info(<span class="pl-s"><span class="pl-pds">"</span>closed <span class="pl-pds">"</span></span> <span class="pl-k">+</span> data<span class="pl-k">.</span>request()<span class="pl-k">.</span>nativeRequest());
                }
            });</pre></div>

<h2>
<a id="user-content-35-subpub--broadcast-event" class="anchor" href="#35-subpub--broadcast-event" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.5 Sub/Pub &amp; broadcast Event</h2>

<p>Suppose our Nginx instance has 3 workers (worker process not jvm_workers which is just thread number of thread pool in jvm). Now we want to provide a sub/pub service. e.g.</p>

<ol>
<li>Client A connected to nginx worker A and subscribed to uri <code>/mychannel/sub</code>
</li>
<li>Client B connected to nginx worker B and subscribed to uri <code>/mychannel/sub</code>
</li>
<li>Client C connected to nginx worker C and publish a message to uri <code>/mychannel/pub</code>
</li>
</ol>

<p>So the service at endpoint of  <code>/mychannel/pub</code> must broadcast a pub event to Client A and Client B.
Although for large-scale application we can use a sub/pub service from Redis on nginx-clojure. For small-scale or medium-scale applications this feature will make the dev's life easier.</p>

<p>More details can be found at <a href="subpub.html">Pub/Sub Among Nginx Worker Processes</a></p>

<h2>
<a id="user-content-36-asynchronous-client-channel" class="anchor" href="#36-asynchronous-client-channel" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.6 Asynchronous Client Channel</h2>

<p>Asynchronous Client Channel is a wrapper of Asynchronous Client Socket made for more easier usage. 
So far Asynchronous Channel <em>can't</em> work with thread pool mode. The Asynchronous Channel 
API is similar to Java 7 NIO.2 Asynchronous Channel and more details can be found from issue #37 and its comments
<a href="https://github.com/nginx-clojure/nginx-clojure/issues/37">Asynchronous Channel API</a>.</p>

<p>Here's an example which is retrieving content from mirror.bit.edu.cn:8080 and sending it to the client.</p>

<ul>
<li><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/test/clojure/nginx/clojure/asyn_channel_handlers_for_test.clj">Clojure Example</a></li>
<li><a href="https://github.com/nginx-clojure/nginx-clojure/blob/master/test/java/nginx/clojure/net/SimpleHandler4TestNginxClojureAsynChannel.java">Java Example</a></li>
</ul>

<h2>
<a id="user-content-37--about-logging" class="anchor" href="#37--about-logging" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.7  About Logging</h2>

<p>For logging with nginx-clojure there are several ways:</p>

<ol>
<li>Using System.err.print/println will write a log to nginx error.log. This way is simplest but logging information will be mixed if you have more than one nginx worker.</li>
<li>Using clojure tools.logging + logback or slf4j +  logback, we can get one log file per nginx worker.</li>
</ol>

<p>e.g</p>

<p>in nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre>
 <span class="pl-k">jvm_options</span> <span class="pl-s">"-DMYPID=#{pno}"</span>;</pre></div>

<p>in logback.xml</p>

<div class="highlight highlight-text-xml"><pre>
 &lt;<span class="pl-ent">appender</span> <span class="pl-e">name</span>=<span class="pl-s"><span class="pl-pds">"</span>FILE<span class="pl-pds">"</span></span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>ch.qos.logback.core.rolling.RollingFileAppender<span class="pl-pds">"</span></span>&gt;
    &lt;<span class="pl-ent">rollingPolicy</span> <span class="pl-e">class</span>=<span class="pl-s"><span class="pl-pds">"</span>ch.qos.logback.core.rolling.TimeBasedRollingPolicy<span class="pl-pds">"</span></span>&gt;
      <span class="pl-c">&lt;!-- daily rollover --&gt;</span>
      &lt;<span class="pl-ent">fileNamePattern</span>&gt;logs/myapp.%d{yyyy-MM-dd}-${MYPID}.log&lt;/<span class="pl-ent">fileNamePattern</span>&gt;
      <span class="pl-c">&lt;!-- keep 30 days' worth of history --&gt;</span>
      &lt;<span class="pl-ent">maxHistory</span>&gt;30&lt;/<span class="pl-ent">maxHistory</span>&gt;
    &lt;/<span class="pl-ent">rollingPolicy</span>&gt;

    &lt;<span class="pl-ent">encoder</span>&gt;
      &lt;<span class="pl-ent">pattern</span>&gt;%d{yyyy-MM-dd HH:mm:ss.SSS} %-5level %-10contextName %logger{36} - %msg%n&lt;/<span class="pl-ent">pattern</span>&gt;
    &lt;/<span class="pl-ent">encoder</span>&gt;
  &lt;/<span class="pl-ent">appender</span>&gt;</pre></div>

<p>Then we'll generate log files named in this convention: myapp.2014-09-12-1.log, myapp.2014-09-12-2.log and so on.</p>

<h2>
<a id="user-content-38--sever-side-websocket" class="anchor" href="#38--sever-side-websocket" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.8  Sever Side WebSocket</h2>

<h3>
<a id="user-content-381-echo-service-example" class="anchor" href="#381-echo-service-example" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.8.1 Echo Service Example</h3>

<p>Sever Side WebSocket, like long polling/Server Sent Events, also use hijack API to get a NginxHttpServerChannel to send / receive messages. 
Here we give a echo service example.</p>

<p>In nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre><span class="pl-k">location</span> <span class="pl-en">/my-ws </span>{
        <span class="pl-k">auto_upgrade_ws</span> on;
        <span class="pl-k">content_handler_type</span> java; <span class="pl-c">###or clojure,groovy</span>
        <span class="pl-k">content_handler_name</span> <span class="pl-s">'nginx.clojure.java.WSEcho'</span>; <span class="pl-c">###or ring handler for clojure</span>
        .....
}</pre></div>

<p>The directive <code>auto_upgrade_ws on</code> is equivalent to </p>

<div class="highlight highlight-source-java"><pre>    <span class="pl-c">//NginxHttpServerChannel sc = r.hijack(true);</span>

        <span class="pl-c">//If we use nginx directive `auto_upgrade_ws on;`, these three lines can be omitted.</span>
        <span class="pl-k">if</span> (<span class="pl-k">!</span>sc<span class="pl-k">.</span>webSocketUpgrade(<span class="pl-c1">true</span>)) {
            <span class="pl-k">return</span> <span class="pl-c1">null</span>;
        }</pre></div>

<p>For clojure</p>

<div class="highlight highlight-source-clojure"><pre>(<span class="pl-k">defn</span> <span class="pl-e">echo</span> [^NginxRequest req]
         (<span class="pl-en">-&gt;</span> req
             (<span class="pl-en">hijack!</span> <span class="pl-c1">true</span>)
             (<span class="pl-en">add-listener!</span> { <span class="pl-c1">:on-open</span> (<span class="pl-k">fn</span> [ch] (<span class="pl-en">log</span> <span class="pl-s"><span class="pl-pds">"</span>uri:%s, on-open!<span class="pl-pds">"</span></span> (<span class="pl-c1">:uri</span> req)))
                              <span class="pl-c1">:on-message</span> (<span class="pl-k">fn</span> [ch msg rem?] (<span class="pl-en">send!</span> ch msg (<span class="pl-en">not</span> rem?) <span class="pl-c1">false</span>))
                              <span class="pl-c1">:on-close</span> (<span class="pl-k">fn</span> [ch reason] (<span class="pl-en">log</span> <span class="pl-s"><span class="pl-pds">"</span>uri:%s, on-close:%s<span class="pl-pds">"</span></span> (<span class="pl-c1">:uri</span> req) reason))
                              <span class="pl-c1">:on-error</span> (<span class="pl-k">fn</span> [ch error] (<span class="pl-en">log</span> <span class="pl-s"><span class="pl-pds">"</span>uri:%s, on-error:%s<span class="pl-pds">"</span></span> (<span class="pl-c1">:uri</span> req)  error))
                             })))</pre></div>

<p>For java </p>

<div class="highlight highlight-source-java"><pre><span class="pl-k">package</span> <span class="pl-smi">nginx.clojure.java</span>;

<span class="pl-k">import</span> <span class="pl-smi">java.io.IOException</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.nio.ByteBuffer</span>;
<span class="pl-k">import</span> <span class="pl-smi">java.util.Map</span>;

<span class="pl-k">import</span> <span class="pl-smi">nginx.clojure.MessageAdapter</span>;
<span class="pl-k">import</span> <span class="pl-smi">nginx.clojure.NginxClojureRT</span>;
<span class="pl-k">import</span> <span class="pl-smi">nginx.clojure.NginxHttpServerChannel</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">WSEcho</span> <span class="pl-k">implements</span> <span class="pl-e">NginxJavaRingHandler</span> {

    <span class="pl-k">@Override</span>
    <span class="pl-k">public</span> <span class="pl-k">Object</span>[] <span class="pl-en">invoke</span>(<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Object</span>&gt;</span> <span class="pl-v">request</span>) {
        <span class="pl-smi">NginxJavaRequest</span> r <span class="pl-k">=</span> (<span class="pl-smi">NginxJavaRequest</span>)request;
        <span class="pl-smi">NginxHttpServerChannel</span> sc <span class="pl-k">=</span> r<span class="pl-k">.</span>hijack(<span class="pl-c1">true</span>);
        sc<span class="pl-k">.</span>addListener(sc, <span class="pl-k">new</span> <span class="pl-k">MessageAdapter&lt;<span class="pl-smi">NginxHttpServerChannel</span>&gt;</span>() {
            <span class="pl-k">int</span> total <span class="pl-k">=</span> <span class="pl-c1">0</span>;
            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onOpen</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">data</span>) {
                <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>debug(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onOpen!<span class="pl-pds">"</span></span>);
            }

            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onTextMessage</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">sc</span>, <span class="pl-smi">String</span> <span class="pl-v">message</span>, <span class="pl-k">boolean</span> <span class="pl-v">remaining</span>) <span class="pl-k">throws</span> <span class="pl-smi">IOException</span> {
                <span class="pl-k">if</span> (<span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>isDebugEnabled()) {
                    <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>debug(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onTextMessage: msg=%s, rem=%s<span class="pl-pds">"</span></span>, message, remaining);
                }
                total <span class="pl-k">+=</span> message<span class="pl-k">.</span>length();
                sc<span class="pl-k">.</span>send(message, <span class="pl-k">!</span>remaining, <span class="pl-c1">false</span>);
            }

            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onBinaryMessage</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">sc</span>, <span class="pl-smi">ByteBuffer</span> <span class="pl-v">message</span>, <span class="pl-k">boolean</span> <span class="pl-v">remining</span>) <span class="pl-k">throws</span> <span class="pl-smi">IOException</span> {
                <span class="pl-k">if</span> (<span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>isDebugEnabled()) {
                    <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>debug(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onBinaryMessage: msg=%s, rem=%s, total=%d<span class="pl-pds">"</span></span>, message, remining, total);
                }
                total <span class="pl-k">+=</span> message<span class="pl-k">.</span>remaining();
                sc<span class="pl-k">.</span>send(message, <span class="pl-k">!</span>remining, <span class="pl-c1">false</span>);
            }

            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onClose</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">req</span>, <span class="pl-k">long</span> <span class="pl-v">status</span>, <span class="pl-smi">String</span> <span class="pl-v">reason</span>) {
                <span class="pl-k">if</span> (<span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>isDebugEnabled()) {
                  <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>info(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onClose2: total=%d, status=%d, reason=%s<span class="pl-pds">"</span></span>, total, status, reason);
                }
            }

            <span class="pl-k">@Override</span>
            <span class="pl-k">public</span> <span class="pl-k">void</span> <span class="pl-en">onError</span>(<span class="pl-smi">NginxHttpServerChannel</span> <span class="pl-v">data</span>, <span class="pl-k">long</span> <span class="pl-v">status</span>) {
                <span class="pl-k">if</span> (<span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>isDebugEnabled()) {
                      <span class="pl-smi">NginxClojureRT</span><span class="pl-k">.</span>log<span class="pl-k">.</span>info(<span class="pl-s"><span class="pl-pds">"</span>WSEcho onError: total=%d, status=%d<span class="pl-pds">"</span></span>, total, status);
                    }
            }

        });
        <span class="pl-k">return</span> <span class="pl-c1">null</span>;
    }

}</pre></div>

<h3>
<a id="user-content-381-use-access-handler-for-websocket-security" class="anchor" href="#381-use-access-handler-for-websocket-security" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.8.1 Use Access Handler For WebSocket Security</h3>

<p>In the example below we return 404 for non WebSocket request </p>

<div class="highlight highlight-source-nginx"><pre><span class="pl-k">location</span> <span class="pl-en">/my-ws </span>{
        <span class="pl-k">auto_upgrade_ws</span> on;
        <span class="pl-k">access_handler_type</span> java;
        <span class="pl-k">access_handler_name</span> <span class="pl-s">'my.WSAccessHandler'</span>;
        <span class="pl-k">content_handler_type</span> java; <span class="pl-c">###or clojure,groovy</span>
        <span class="pl-k">content_handler_name</span> <span class="pl-s">'nginx.clojure.java.WSEcho'</span>; <span class="pl-c">###or ring handler for clojure</span>
        .....
}</pre></div>

<div class="highlight highlight-source-java"><pre><span class="pl-k">package</span> <span class="pl-smi">my</span>;
<span class="pl-k">import</span> <span class="pl-smi">nginx.clojure.java.NginxJavaRingHandler</span>;
<span class="pl-k">import static</span> <span class="pl-smi">nginx.clojure.java.Constants.*</span>;

<span class="pl-k">public</span> <span class="pl-k">class</span> <span class="pl-en">WSAccessHandler</span> <span class="pl-k">implements</span> <span class="pl-e">NginxJavaRingHandler</span> {
  <span class="pl-k">public</span> <span class="pl-k">Object</span>[] <span class="pl-en">invoke</span>(<span class="pl-k">Map&lt;<span class="pl-smi">String</span>, <span class="pl-smi">Object</span>&gt;</span> <span class="pl-v">request</span>) {
    <span class="pl-k">if</span> (<span class="pl-c1">GET</span> <span class="pl-k">!=</span> request<span class="pl-k">.</span>get(<span class="pl-s"><span class="pl-pds">"</span>request-method<span class="pl-pds">"</span></span>) 
        <span class="pl-k">||</span> <span class="pl-k">!</span><span class="pl-s"><span class="pl-pds">"</span>websocket<span class="pl-pds">"</span></span><span class="pl-k">.</span>equals(request<span class="pl-k">.</span>get(<span class="pl-s"><span class="pl-pds">"</span>headers<span class="pl-pds">"</span></span>)<span class="pl-k">.</span>get(<span class="pl-s"><span class="pl-pds">"</span>upgrade<span class="pl-pds">"</span></span>))) {
      <span class="pl-k">return</span> <span class="pl-k">new</span> <span class="pl-smi">Object</span>[]{<span class="pl-c1">404</span>, <span class="pl-c1">null</span>, <span class="pl-c1">null</span>};
    }
    <span class="pl-k">return</span> <span class="pl-c1">PHASE_DONE</span>;
  }
}
</pre></div>

<h2>
<a id="user-content-39--java-standard-restful-web-services-with-jersey" class="anchor" href="#39--java-standard-restful-web-services-with-jersey" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.9  Java standard RESTful web services with Jersey</h2>

<ul>
<li><strong>Get Jar File</strong></li>
</ul>

<p>We can get the released version from <a href="https://clojars.org/nginx-clojure/nginx-jersey">clojars</a> or 
the jar in <a href="https://sourceforge.net/projects/nginx-clojure/files/">nginx-clojure binary release</a> </p>

<p>To get the latest version from the github source</p>

<div class="highlight highlight-source-shell"><pre>git clone https://github.com/nginx-clojure/nginx-clojure
<span class="pl-c1">cd</span> nginx-clojure/nginx-jersey
lein jar</pre></div>

<ul>
<li> <strong>Configuration</strong>
</li>
</ul>

<p>in nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre>      <span class="pl-k">location</span> <span class="pl-en">/jersey </span>{

          <span class="pl-k">content_handler_type</span> java;
          <span class="pl-k">content_handler_name</span> <span class="pl-s">'nginx.clojure.bridge.NginxBridgeHandler'</span>;

          <span class="pl-c">##we can set system properties ,e.g. m2rep</span>
          <span class="pl-c">#content_handler_property system.m2rep '/home/who/.m2/repository';</span>

          <span class="pl-c">##we can put jars into some dir then all of their path will be appended into the classpath</span>
          <span class="pl-c">#content_handler_property bridge.lib.dirs 'my-jersey-libs-dir:myother-dir';</span>

          <span class="pl-c">##the path of nginx-jersey-x.x.x.jar must be included in the below classpath or one of above #{bridge.lib.dirs}</span>
          <span class="pl-c">##we can use maven assembly plugin to get a all-in-one jar file with dependencies, e.g. json-jackson-example-with-dependencies.jar.</span>
          <span class="pl-k">content_handler_property</span> bridge.lib.cp <span class="pl-s">'jars/nginx-jersey-0.1.0.jar:myjars/json-jackson-example-with-dependencies.jar'</span>;
          <span class="pl-k">content_handler_property</span> bridge.imp <span class="pl-s">'nginx.clojure.jersey.NginxJerseyContainer'</span>;

          <span class="pl-c">##aplication path usually it is the same with nginx location </span>
          <span class="pl-k">content_handler_property</span> jersey.app.path <span class="pl-s">'/jersey'</span>;

          <span class="pl-c">##application resources which can be either of JAX-RS resources, providers</span>
          <span class="pl-k">content_handler_property</span> jersey.app.resources <span class="pl-s">'</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.EmptyArrayResource,</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.NonJaxbBeanResource,</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.CombinedAnnotationResource,</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.MyObjectMapperProvider,</span>
<span class="pl-s">                org.glassfish.jersey.examples.jackson.ExceptionMappingTestResource,</span>
<span class="pl-s">                org.glassfish.jersey.jackson.JacksonFeature</span>
<span class="pl-s">          '</span>;
          <span class="pl-k">gzip</span><span class="pl-c1"> on</span>;
          <span class="pl-k">gzip_types</span> application/javascript application/xml text/plain text/css <span class="pl-s">'text/html;charset=UTF-8'</span>; 
      }</pre></div>

<p>All sources about this example can be found from jersey github repository's example <a href="https://github.com/jersey/jersey/tree/2.17/examples/json-jackson/src/main/java/org/glassfish/jersey/examples/jackson">json-jackson</a>.</p>

<p>Then we test the JAX-RS services by curl</p>

<div class="highlight highlight-source-shell"><pre>$ curl  -v http://localhost:8080/jersey/emptyArrayResource
<span class="pl-k">&gt;</span> GET /jersey/emptyArrayResource HTTP/1.1
<span class="pl-k">&gt;</span> User-Agent: curl/7.35.0
<span class="pl-k">&gt;</span> Host: localhost:8080
<span class="pl-k">&gt;</span> Accept: <span class="pl-k">*</span>/<span class="pl-k">*</span>
<span class="pl-k">&gt;</span> 
<span class="pl-k">&lt;</span> HTTP/1.1 200 OK
<span class="pl-k">&lt;</span> Date: Sat, 23 May 2015 17:47:14 GMT
<span class="pl-k">&lt;</span> Content-Type: application/json
<span class="pl-k">&lt;</span> Transfer-Encoding: chunked
<span class="pl-k">&lt;</span> Connection: keep-alive
<span class="pl-k">*</span> Server nginx-clojure is not blacklisted
<span class="pl-k">&lt;</span> Server: nginx-clojure
<span class="pl-k">&lt;</span> 
{
  <span class="pl-s"><span class="pl-pds">"</span>emtpyArray<span class="pl-pds">"</span></span> <span class="pl-c1">:</span> [ ]
}</pre></div>

<div class="highlight highlight-source-shell"><pre>$ curl -v http://localhost:8080/jersey/nonJaxbResource
<span class="pl-k">&gt;</span> GET /jersey/nonJaxbResource HTTP/1.1
<span class="pl-k">&gt;</span> User-Agent: curl/7.35.0
<span class="pl-k">&gt;</span> Host: localhost:8080
<span class="pl-k">&gt;</span> Accept: <span class="pl-k">*</span>/<span class="pl-k">*</span>
<span class="pl-k">&gt;</span> 
<span class="pl-k">&lt;</span> HTTP/1.1 200 OK
<span class="pl-k">&lt;</span> Date: Sat, 23 May 2015 17:46:17 GMT
<span class="pl-k">&lt;</span> Content-Type: application/javascript
<span class="pl-k">&lt;</span> Transfer-Encoding: chunked
<span class="pl-k">&lt;</span> Connection: keep-alive
<span class="pl-k">*</span> Server nginx-clojure is not blacklisted
<span class="pl-k">&lt;</span> Server: nginx-clojure
<span class="pl-k">&lt;</span> 
callback({
  <span class="pl-s"><span class="pl-pds">"</span>name<span class="pl-pds">"</span></span> <span class="pl-c1">:</span> <span class="pl-s"><span class="pl-pds">"</span>non-JAXB-bean<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>description<span class="pl-pds">"</span></span> <span class="pl-c1">:</span> <span class="pl-s"><span class="pl-pds">"</span>I am not a JAXB bean, just an unannotated POJO<span class="pl-pds">"</span></span>,
  <span class="pl-s"><span class="pl-pds">"</span>array<span class="pl-pds">"</span></span> <span class="pl-c1">:</span> [ 1, 1, 2, 3, 5, 8, 13, 21 ]
<span class="pl-k">*</span> Connection <span class="pl-c">#0 to host localhost left intact</span>
})</pre></div>

<h2>
<a id="user-content-310-embeding-tomcat" class="anchor" href="#310-embeding-tomcat" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.10 Embeding Tomcat</h2>

<h3>
<a id="user-content-which-version" class="anchor" href="#which-version" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Which Version?</h3>

<table>
<thead>
<tr>
<th>Apache Tomcat version</th>
<th>Nginx-Clojure version</th>
<th>Nginx-Tomcat8 version</th>
</tr>
</thead>
<tbody>
<tr>
<td>8.0.20</td>
<td>&gt;=0.4.x</td>
<td>0.1.x</td>
</tr>
<tr>
<td>8.0.23,8.0.24</td>
<td>&gt;=0.4.x</td>
<td>0.2.x</td>
</tr>
</tbody>
</table>

<h3>
<a id="user-content-get-jar-file" class="anchor" href="#get-jar-file" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Get Jar File</h3>

<p>We can get the released version from <a href="https://clojars.org/nginx-clojure/nginx-tomcat8">clojars</a> or 
the jar in <a href="https://sourceforge.net/projects/nginx-clojure/files/">nginx-clojure binary release</a> </p>

<p>To get the latest version from the github source</p>

<div class="highlight highlight-source-shell"><pre>git clone https://github.com/nginx-clojure/nginx-clojure
<span class="pl-c1">cd</span> nginx-clojure/nginx-tomcat8
lein jar</pre></div>

<h3>
<a id="user-content-configuration" class="anchor" href="#configuration" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Configuration</h3>

<p>in nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre>      <span class="pl-k">location</span> <span class="pl-en">/ </span>{

          <span class="pl-k">content_handler_type</span> java;
          <span class="pl-k">content_handler_name</span> <span class="pl-s">'nginx.clojure.bridge.NginxBridgeHandler'</span>;

          <span class="pl-c">##Tomcat 8 installation path</span>
          <span class="pl-k">content_handler_property</span> system.catalina.home <span class="pl-s">'/home/who/share/apps/apache-tomcat-8.0.20'</span>;
          <span class="pl-k">content_handler_property</span> system.catalina.base <span class="pl-s">'#{catalina.home}'</span>;

          <span class="pl-c">##uncomment this to disable websocket perframe-compression</span>
          <span class="pl-c">#content_handler_property system.org.apache.tomcat.websocket.DISABLE_BUILTIN_EXTENSIONS true;</span>

          <span class="pl-c">##log manger</span>
          <span class="pl-k">content_handler_property</span> system.java.util.logging.manager <span class="pl-s">'org.apache.juli.ClassLoaderLogManager'</span>;

          <span class="pl-c">## all jars or direct child directories will be appended into the classpath of this bridge handler's class-loader</span>
          <span class="pl-k">content_handler_property</span> bridge.lib.dirs <span class="pl-s">'#{catalina.home}/lib:#{catalina.home}/bin'</span>;

          <span class="pl-c">##set nginx tomcat8 bridge implementation jar and other jars can also be appended here</span>
          <span class="pl-k">content_handler_property</span> bridge.lib.cp <span class="pl-s">'my-jar-path/nginx-tomcat8-x.x.x.jar'</span>;

          <span class="pl-c">##The implementation class of nginx-clojure bridge handler for Tomcat 8</span>
          <span class="pl-k">content_handler_property</span> bridge.imp <span class="pl-s">'nginx.clojure.tomcat8.NginxTomcatBridge'</span>;

          <span class="pl-c">##ignore nginx filter, default is false</span>
          <span class="pl-c">#content_handler_property ignoreNginxFilter false;</span>

          <span class="pl-c">##when dispatch is false tomcat servlet will be executed in main thread. By default dispatch is false</span>
          <span class="pl-c">##when use websocket with tomcat it must be set true otherwise maybe deadlock will happen.</span>
          <span class="pl-c">#content_handler_property dispatch false;</span>

          <span class="pl-k">gzip</span><span class="pl-c1"> on</span>;
          <span class="pl-k">gzip_types</span> text/plain text/css <span class="pl-s">'text/html;charset=ISO-8859-1'</span> <span class="pl-s">'text/html;charset=UTF-8'</span>; 

          <span class="pl-c">##if for small message, e.g. small json/websocket message write_page_size can set to be a small value</span>
          <span class="pl-c">#write_page_size 2k;</span>
      }</pre></div>

<h2>
<a id="user-content-session-management" class="anchor" href="#session-management" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Session Management</h2>

<p>If <code>worker_processes</code> &gt; 1 there will be more than one jvm instances viz. more tomcat instances so to get synchronized session information we cannot use the default tomcat session manger.
Instead we may consider using one of the following:</p>

<ol>
<li>Cookied based Session Store  viz. storing all session attribute information into cookies.</li>
<li>Shared HashMap among processes in the same machine ,e.g. nginx-clojure built-in <a href="https://nginx-clojure.github.io/sharedmap.html">Shared Map</a>, OpenHFT <a href="https://github.com/OpenHFT/Chronicle-Map">Chronicle Map</a>
</li>
<li>External Session Store,  e.g.  Redis / MySQL / Memcached Session Store</li>
</ol>

<h3>
<a id="user-content-for-performance" class="anchor" href="#for-performance" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>For Performance</h3>

<h4>
<a id="user-content-disable-tomcat-access-log" class="anchor" href="#disable-tomcat-access-log" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Disable Tomcat Access Log</h4>

<p>When we need the access log, use Nginx's access log instead of Tomcat's access log.</p>

<p>In server.xml comment out AccessLogValve configuration to disable Tomcat access log.</p>

<div class="highlight highlight-text-xml"><pre><span class="pl-c">&lt;!--</span>
<span class="pl-c">        &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"</span>
<span class="pl-c">               prefix="localhost_access_log" suffix=".txt"</span>
<span class="pl-c">               pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt;</span>
<span class="pl-c">--&gt;</span></pre></div>

<h4>
<a id="user-content-disable-logging-to-console" class="anchor" href="#disable-logging-to-console" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Disable logging to console</h4>

<p>Because Tomcat console log is duplicated with other logs such as catalina log, manager log, etc, it can be disabled.
In conf/logging.properties remove all <code>java.util.logging.ConsoleHandler</code></p>

<div class="highlight highlight-source-shell"><pre>handlers = 1catalina.org.apache.juli.AsyncFileHandler, 2localhost.org.apache.juli.AsyncFileHandler, 3manager.org.apache.juli.AsyncFileHandler, 4host-manager.org.apache.juli.AsyncFileHandler

.handlers = 1catalina.org.apache.juli.AsyncFileHandler</pre></div>

<h4>
<a id="user-content-dont-enable-tomcat-compression" class="anchor" href="#dont-enable-tomcat-compression" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Don't Enable Tomcat Compression</h4>

<p>By default compression is off, do not turn it on.</p>

<div class="highlight highlight-text-xml"><pre>&lt;<span class="pl-ent">Connector</span> <span class="pl-e">port</span>=<span class="pl-s"><span class="pl-pds">"</span>8080<span class="pl-pds">"</span></span> <span class="pl-e">protocol</span>=<span class="pl-s"><span class="pl-pds">"</span>HTTP/1.1<span class="pl-pds">"</span></span> <span class="pl-e">compression</span>=<span class="pl-s"><span class="pl-pds">"</span>off<span class="pl-pds">"</span></span></pre></div>

<p>If we need compression use nginx gzip filter instead. e.g. In nginx.conf</p>

<div class="highlight highlight-source-nginx"><pre><span class="pl-k">location</span> <span class="pl-en">/examples </span>{
    <span class="pl-k">gzip</span><span class="pl-c1"> on</span>;
    <span class="pl-k">gzip_types</span> text/plain text/css <span class="pl-s">'text/html;charset=ISO-8859-1'</span> <span class="pl-s">'text/html;charset=UTF-8'</span>; 
}</pre></div>

<p><code>gzip</code> can also appear under http and server blocks. More details can be found <a href="http://nginx.org/en/docs/http/ngx_http_gzip_module.html">HERE</a></p>

<h2>
<a id="user-content-311-more-about-nginx-worker-process" class="anchor" href="#311-more-about-nginx-worker-process" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>3.11 More about Nginx Worker Process</h2>

<p>The number of Nginx worker processes can be configured by nginx directive <a href="http://nginx.org/en/docs/ngx_core_module.html#worker_processes">worker_processes</a>.
e.g. We use 8 Nginx worker processes:</p>

<div class="highlight highlight-source-nginx"><pre><span class="pl-k">worker_processes</span> <span class="pl-s">8</span>;</pre></div>

<p>Because a JVM instance will be embeded into every Nginx worker process, if there are more than one Nginx worker prcocesses then there will be more than one JVM instances.
So if we want to have synchronized session information we cannot use the default tomcat session manger. Instead we may consider using one of the following: </p>

<ol>
<li>Cookie based Session Store  viz. storing all session attribute information into cookies.</li>
<li>Shared HashMap among processes in the same machine ,e.g. nginx-clojure built-in <a href="https://nginx-clojure.github.io/sharedmap.html">Shared Map</a>, OpenHFT <a href="https://github.com/OpenHFT/Chronicle-Map">Chronicle Map</a>
</li>
<li>External Session Store,  e.g.  Redis / MySQL / Memcached Session Store</li>
</ol>

<p>When there are is than one Nginx worker process, sub/pub services also need to be taken care for. Subscribers may connect to JVM instances which may be different
than the JVM instance which the publisher sent a message to. So we need to use <a href="more.html#35-subpub--broadcast-event">broadcast API</a> from nginx-clojure
and broadcast messages to all Nginx worker processes.</p>
